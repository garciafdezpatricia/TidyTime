'use strict';

var solidClient = require('@inrupt/solid-client');
var n3 = require('n3');
var eventEmitterPromisify = require('event-emitter-promisify');
var jsonldContextParser = require('jsonld-context-parser');
var jsonldStreamingParser = require('jsonld-streaming-parser');
var md5 = require('md5');
var rdfNamespaces = require('rdf-namespaces');

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * The Verifiable Credentials context.
 * @see https://www.w3.org/2018/credentials/v1
 */
var VC = {
    "@context": {
        "@version": 1.1,
        "@protected": true,
        id: "@id",
        type: "@type",
        VerifiableCredential: {
            "@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
            "@context": {
                "@version": 1.1,
                "@protected": true,
                id: "@id",
                type: "@type",
                cred: "https://www.w3.org/2018/credentials#",
                sec: "https://w3id.org/security#",
                xsd: "http://www.w3.org/2001/XMLSchema#",
                credentialSchema: {
                    "@id": "cred:credentialSchema",
                    "@type": "@id",
                    "@context": {
                        "@version": 1.1,
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        cred: "https://www.w3.org/2018/credentials#",
                        JsonSchemaValidator2018: "cred:JsonSchemaValidator2018",
                    },
                },
                credentialStatus: { "@id": "cred:credentialStatus", "@type": "@id" },
                credentialSubject: { "@id": "cred:credentialSubject", "@type": "@id" },
                evidence: { "@id": "cred:evidence", "@type": "@id" },
                expirationDate: {
                    "@id": "cred:expirationDate",
                    "@type": "xsd:dateTime",
                },
                holder: { "@id": "cred:holder", "@type": "@id" },
                issued: { "@id": "cred:issued", "@type": "xsd:dateTime" },
                issuer: { "@id": "cred:issuer", "@type": "@id" },
                issuanceDate: { "@id": "cred:issuanceDate", "@type": "xsd:dateTime" },
                proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
                refreshService: {
                    "@id": "cred:refreshService",
                    "@type": "@id",
                    "@context": {
                        "@version": 1.1,
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        cred: "https://www.w3.org/2018/credentials#",
                        ManualRefreshService2018: "cred:ManualRefreshService2018",
                    },
                },
                termsOfUse: { "@id": "cred:termsOfUse", "@type": "@id" },
                validFrom: { "@id": "cred:validFrom", "@type": "xsd:dateTime" },
                validUntil: { "@id": "cred:validUntil", "@type": "xsd:dateTime" },
            },
        },
        VerifiablePresentation: {
            "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
            "@context": {
                "@version": 1.1,
                "@protected": true,
                id: "@id",
                type: "@type",
                cred: "https://www.w3.org/2018/credentials#",
                sec: "https://w3id.org/security#",
                holder: { "@id": "cred:holder", "@type": "@id" },
                proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
                verifiableCredential: {
                    "@id": "cred:verifiableCredential",
                    "@type": "@id",
                    "@container": "@graph",
                },
            },
        },
        EcdsaSecp256k1Signature2019: {
            "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
            "@context": {
                "@version": 1.1,
                "@protected": true,
                id: "@id",
                type: "@type",
                sec: "https://w3id.org/security#",
                xsd: "http://www.w3.org/2001/XMLSchema#",
                challenge: "sec:challenge",
                created: {
                    "@id": "http://purl.org/dc/terms/created",
                    "@type": "xsd:dateTime",
                },
                domain: "sec:domain",
                expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
                jws: "sec:jws",
                nonce: "sec:nonce",
                proofPurpose: {
                    "@id": "sec:proofPurpose",
                    "@type": "@vocab",
                    "@context": {
                        "@version": 1.1,
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        sec: "https://w3id.org/security#",
                        assertionMethod: {
                            "@id": "sec:assertionMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        authentication: {
                            "@id": "sec:authenticationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                    },
                },
                proofValue: "sec:proofValue",
                verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" },
            },
        },
        EcdsaSecp256r1Signature2019: {
            "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
            "@context": {
                "@version": 1.1,
                "@protected": true,
                id: "@id",
                type: "@type",
                sec: "https://w3id.org/security#",
                xsd: "http://www.w3.org/2001/XMLSchema#",
                challenge: "sec:challenge",
                created: {
                    "@id": "http://purl.org/dc/terms/created",
                    "@type": "xsd:dateTime",
                },
                domain: "sec:domain",
                expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
                jws: "sec:jws",
                nonce: "sec:nonce",
                proofPurpose: {
                    "@id": "sec:proofPurpose",
                    "@type": "@vocab",
                    "@context": {
                        "@version": 1.1,
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        sec: "https://w3id.org/security#",
                        assertionMethod: {
                            "@id": "sec:assertionMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        authentication: {
                            "@id": "sec:authenticationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                    },
                },
                proofValue: "sec:proofValue",
                verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" },
            },
        },
        Ed25519Signature2018: {
            "@id": "https://w3id.org/security#Ed25519Signature2018",
            "@context": {
                "@version": 1.1,
                "@protected": true,
                id: "@id",
                type: "@type",
                sec: "https://w3id.org/security#",
                xsd: "http://www.w3.org/2001/XMLSchema#",
                challenge: "sec:challenge",
                created: {
                    "@id": "http://purl.org/dc/terms/created",
                    "@type": "xsd:dateTime",
                },
                domain: "sec:domain",
                expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
                jws: "sec:jws",
                nonce: "sec:nonce",
                proofPurpose: {
                    "@id": "sec:proofPurpose",
                    "@type": "@vocab",
                    "@context": {
                        "@version": 1.1,
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        sec: "https://w3id.org/security#",
                        assertionMethod: {
                            "@id": "sec:assertionMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        authentication: {
                            "@id": "sec:authenticationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                    },
                },
                proofValue: "sec:proofValue",
                verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" },
            },
        },
        RsaSignature2018: {
            "@id": "https://w3id.org/security#RsaSignature2018",
            "@context": {
                "@version": 1.1,
                "@protected": true,
                challenge: "sec:challenge",
                created: {
                    "@id": "http://purl.org/dc/terms/created",
                    "@type": "xsd:dateTime",
                },
                domain: "sec:domain",
                expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
                jws: "sec:jws",
                nonce: "sec:nonce",
                proofPurpose: {
                    "@id": "sec:proofPurpose",
                    "@type": "@vocab",
                    "@context": {
                        "@version": 1.1,
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        sec: "https://w3id.org/security#",
                        assertionMethod: {
                            "@id": "sec:assertionMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        authentication: {
                            "@id": "sec:authenticationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                    },
                },
                proofValue: "sec:proofValue",
                verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" },
            },
        },
        proof: {
            "@id": "https://w3id.org/security#proof",
            "@type": "@id",
            "@container": "@graph",
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * The custom Inrupt context for verifiable credentials
 * @see https://schema.inrupt.com/credentials/v1.jsonld
 */
var Inrupt = {
    "@context": {
        "@version": 1.1,
        "@protected": true,
        ldp: "http://www.w3.org/ns/ldp#",
        acl: "http://www.w3.org/ns/auth/acl#",
        gc: "https://w3id.org/GConsent#",
        vc: "http://www.w3.org/ns/solid/vc#",
        xsd: "http://www.w3.org/2001/XMLSchema#",
        issuerService: {
            "@id": "vc:issuerService",
            "@type": "@id",
        },
        statusService: {
            "@id": "vc:statusService",
            "@type": "@id",
        },
        verifierService: {
            "@id": "vc:verifierService",
            "@type": "@id",
        },
        derivationService: {
            "@id": "vc:derivationService",
            "@type": "@id",
        },
        proofService: {
            "@id": "vc:proofService",
            "@type": "@id",
        },
        availabilityService: {
            "@id": "vc:availabilityService",
            "@type": "@id",
        },
        submissionService: {
            "@id": "vc:submissionService",
            "@type": "@id",
        },
        supportedSignatureTypes: {
            "@id": "vc:supportedSignatureTypes",
            "@type": "@id",
        },
        include: {
            "@id": "vc:include",
            "@type": "@id",
        },
        SolidAccessGrant: "vc:SolidAccessGrant",
        SolidAccessRequest: "vc:SolidAccessRequest",
        ExpiredVerifiableCredential: "vc:ExpiredVerifiableCredential",
        inbox: {
            "@id": "ldp:inbox",
            "@type": "@id",
        },
        Read: "acl:Read",
        Write: "acl:Write",
        Append: "acl:Append",
        mode: {
            "@id": "acl:mode",
            "@type": "@vocab",
        },
        Consent: "gc:Consent",
        ConsentStatusExpired: "gc:ConsentStatusExpired",
        ConsentStatusExplicitlyGiven: "gc:ConsentStatusExplicitlyGiven",
        ConsentStatusGivenByDelegation: "gc:ConsentStatusGivenByDelegation",
        ConsentStatusImplicitlyGiven: "gc:ConsentStatusImplicitlyGiven",
        ConsentStatusInvalidated: "gc:ConsentStatusInvalidated",
        ConsentStatusNotGiven: "gc:ConsentStatusNotGiven",
        ConsentStatusRefused: "gc:ConsentStatusRefused",
        ConsentStatusRequested: "gc:ConsentStatusRequested",
        ConsentStatusUnknown: "gc:ConsentStatusUnknown",
        ConsentStatusWithdrawn: "gc:ConsentStatusWithdrawn",
        forPersonalData: {
            "@id": "gc:forPersonalData",
            "@type": "@id",
        },
        forProcessing: {
            "@id": "gc:forProcessing",
            "@type": "@id",
        },
        forPurpose: {
            "@id": "gc:forPurpose",
            "@type": "@id",
        },
        hasConsent: {
            "@id": "gc:hasConsent",
            "@type": "@id",
        },
        hasContext: {
            "@id": "gc:hasContext",
            "@type": "@id",
        },
        hasStatus: {
            "@id": "gc:hasStatus",
            "@type": "@vocab",
        },
        inMedium: {
            "@id": "gc:inMedium",
            "@type": "@id",
        },
        isConsentForDataSubject: {
            "@id": "gc:isConsentForDataSubject",
            "@type": "@id",
        },
        isProvidedTo: {
            "@id": "gc:isProvidedTo",
            "@type": "@id",
        },
        isProvidedToPerson: {
            "@id": "gc:isProvidedToPerson",
            "@type": "@id",
        },
        isProvidedToController: {
            "@id": "gc:isProvidedToController",
            "@type": "@id",
        },
        providedConsent: {
            "@id": "gc:providedConsent",
            "@type": "@id",
        },
        inherit: {
            "@id": "urn:uuid:71ab2f68-a68b-4452-b968-dd23e0570227",
            "@type": "xsd:boolean",
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @see https://vc.inrupt.com/credentials/v1
 */
var vc = {
    "@context": {
        "@version": 1.1,
        "@protected": true,
        ldp: "http://www.w3.org/ns/ldp#",
        acl: "http://www.w3.org/ns/auth/acl#",
        gc: "https://w3id.org/GConsent#",
        vc: "http://www.w3.org/ns/solid/vc#",
        xsd: "http://www.w3.org/2001/XMLSchema#",
        issuerService: { "@id": "vc:issuerService", "@type": "@id" },
        statusService: { "@id": "vc:statusService", "@type": "@id" },
        verifierService: { "@id": "vc:verifierService", "@type": "@id" },
        derivationService: { "@id": "vc:derivationService", "@type": "@id" },
        proofService: { "@id": "vc:proofService", "@type": "@id" },
        availabilityService: { "@id": "vc:availabilityService", "@type": "@id" },
        submissionService: { "@id": "vc:submissionService", "@type": "@id" },
        supportedSignatureTypes: {
            "@id": "vc:supportedSignatureTypes",
            "@type": "@id",
        },
        include: { "@id": "vc:include", "@type": "@id" },
        SolidAccessGrant: "vc:SolidAccessGrant",
        SolidAccessRequest: "vc:SolidAccessRequest",
        ExpiredVerifiableCredential: "vc:ExpiredVerifiableCredential",
        inbox: { "@id": "ldp:inbox", "@type": "@id" },
        Read: "acl:Read",
        Write: "acl:Write",
        Append: "acl:Append",
        mode: { "@id": "acl:mode", "@type": "@vocab" },
        Consent: "gc:Consent",
        ConsentStatusExpired: "gc:ConsentStatusExpired",
        ConsentStatusExplicitlyGiven: "gc:ConsentStatusExplicitlyGiven",
        ConsentStatusGivenByDelegation: "gc:ConsentStatusGivenByDelegation",
        ConsentStatusImplicitlyGiven: "gc:ConsentStatusImplicitlyGiven",
        ConsentStatusInvalidated: "gc:ConsentStatusInvalidated",
        ConsentStatusNotGiven: "gc:ConsentStatusNotGiven",
        ConsentStatusRefused: "gc:ConsentStatusRefused",
        ConsentStatusRequested: "gc:ConsentStatusRequested",
        ConsentStatusUnknown: "gc:ConsentStatusUnknown",
        ConsentStatusWithdrawn: "gc:ConsentStatusWithdrawn",
        forPersonalData: { "@id": "gc:forPersonalData", "@type": "@id" },
        forProcessing: { "@id": "gc:forProcessing", "@type": "@id" },
        forPurpose: { "@id": "gc:forPurpose", "@type": "@id" },
        hasConsent: { "@id": "gc:hasConsent", "@type": "@id" },
        hasContext: { "@id": "gc:hasContext", "@type": "@id" },
        hasStatus: { "@id": "gc:hasStatus", "@type": "@vocab" },
        inMedium: { "@id": "gc:inMedium", "@type": "@id" },
        isConsentForDataSubject: {
            "@id": "gc:isConsentForDataSubject",
            "@type": "@id",
        },
        isProvidedTo: { "@id": "gc:isProvidedTo", "@type": "@id" },
        isProvidedToPerson: { "@id": "gc:isProvidedToPerson", "@type": "@id" },
        isProvidedToController: {
            "@id": "gc:isProvidedToController",
            "@type": "@id",
        },
        providedConsent: { "@id": "gc:providedConsent", "@type": "@id" },
        inherit: {
            "@id": "urn:uuid:71ab2f68-a68b-4452-b968-dd23e0570227",
            "@type": "xsd:boolean",
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @see https://w3id.org/security/data-integrity/v1
 */
var integrity = {
    "@context": {
        id: "@id",
        type: "@type",
        "@protected": true,
        proof: {
            "@id": "https://w3id.org/security#proof",
            "@type": "@id",
            "@container": "@graph",
        },
        DataIntegrityProof: {
            "@id": "https://w3id.org/security#DataIntegrityProof",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                challenge: "https://w3id.org/security#challenge",
                created: {
                    "@id": "http://purl.org/dc/terms/created",
                    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                },
                domain: "https://w3id.org/security#domain",
                expires: {
                    "@id": "https://w3id.org/security#expiration",
                    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                },
                nonce: "https://w3id.org/security#nonce",
                proofPurpose: {
                    "@id": "https://w3id.org/security#proofPurpose",
                    "@type": "@vocab",
                    "@context": {
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        assertionMethod: {
                            "@id": "https://w3id.org/security#assertionMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        authentication: {
                            "@id": "https://w3id.org/security#authenticationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        capabilityInvocation: {
                            "@id": "https://w3id.org/security#capabilityInvocationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        capabilityDelegation: {
                            "@id": "https://w3id.org/security#capabilityDelegationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        keyAgreement: {
                            "@id": "https://w3id.org/security#keyAgreementMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                    },
                },
                cryptosuite: "https://w3id.org/security#cryptosuite",
                proofValue: {
                    "@id": "https://w3id.org/security#proofValue",
                    "@type": "https://w3id.org/security#multibase",
                },
                verificationMethod: {
                    "@id": "https://w3id.org/security#verificationMethod",
                    "@type": "@id",
                },
            },
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @see https://w3id.org/security/suites/ed25519-2020/v1
 */
var ed25519 = {
    "@context": {
        id: "@id",
        type: "@type",
        "@protected": true,
        proof: {
            "@id": "https://w3id.org/security#proof",
            "@type": "@id",
            "@container": "@graph",
        },
        Ed25519VerificationKey2020: {
            "@id": "https://w3id.org/security#Ed25519VerificationKey2020",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                controller: {
                    "@id": "https://w3id.org/security#controller",
                    "@type": "@id",
                },
                revoked: {
                    "@id": "https://w3id.org/security#revoked",
                    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                },
                publicKeyMultibase: {
                    "@id": "https://w3id.org/security#publicKeyMultibase",
                    "@type": "https://w3id.org/security#multibase",
                },
            },
        },
        Ed25519Signature2020: {
            "@id": "https://w3id.org/security#Ed25519Signature2020",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                challenge: "https://w3id.org/security#challenge",
                created: {
                    "@id": "http://purl.org/dc/terms/created",
                    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                },
                domain: "https://w3id.org/security#domain",
                expires: {
                    "@id": "https://w3id.org/security#expiration",
                    "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
                },
                nonce: "https://w3id.org/security#nonce",
                proofPurpose: {
                    "@id": "https://w3id.org/security#proofPurpose",
                    "@type": "@vocab",
                    "@context": {
                        "@protected": true,
                        id: "@id",
                        type: "@type",
                        assertionMethod: {
                            "@id": "https://w3id.org/security#assertionMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        authentication: {
                            "@id": "https://w3id.org/security#authenticationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        capabilityInvocation: {
                            "@id": "https://w3id.org/security#capabilityInvocationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        capabilityDelegation: {
                            "@id": "https://w3id.org/security#capabilityDelegationMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                        keyAgreement: {
                            "@id": "https://w3id.org/security#keyAgreementMethod",
                            "@type": "@id",
                            "@container": "@set",
                        },
                    },
                },
                proofValue: {
                    "@id": "https://w3id.org/security#proofValue",
                    "@type": "https://w3id.org/security#multibase",
                },
                verificationMethod: {
                    "@id": "https://w3id.org/security#verificationMethod",
                    "@type": "@id",
                },
            },
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @see https://w3id.org/vc-revocation-list-2020/v1
 */
var revocation = {
    "@context": {
        "@protected": true,
        RevocationList2020Credential: {
            "@id": "https://w3id.org/vc-revocation-list-2020#RevocationList2020Credential",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                description: "http://schema.org/description",
                name: "http://schema.org/name",
            },
        },
        RevocationList2020: {
            "@id": "https://w3id.org/vc-revocation-list-2020#RevocationList2020",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                encodedList: "https://w3id.org/vc-revocation-list-2020#encodedList",
            },
        },
        RevocationList2020Status: {
            "@id": "https://w3id.org/vc-revocation-list-2020#RevocationList2020Status",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                revocationListCredential: {
                    "@id": "https://w3id.org/vc-revocation-list-2020#revocationListCredential",
                    "@type": "@id",
                },
                revocationListIndex: "https://w3id.org/vc-revocation-list-2020#revocationListIndex",
            },
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * @see https://w3id.org/vc/status-list/2021/v1
 */
var statusList = {
    "@context": {
        "@protected": true,
        StatusList2021Credential: {
            "@id": "https://w3id.org/vc/status-list#StatusList2021Credential",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                description: "http://schema.org/description",
                name: "http://schema.org/name",
            },
        },
        StatusList2021: {
            "@id": "https://w3id.org/vc/status-list#StatusList2021",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                statusPurpose: "https://w3id.org/vc/status-list#statusPurpose",
                encodedList: "https://w3id.org/vc/status-list#encodedList",
            },
        },
        StatusList2021Entry: {
            "@id": "https://w3id.org/vc/status-list#StatusList2021Entry",
            "@context": {
                "@protected": true,
                id: "@id",
                type: "@type",
                statusPurpose: "https://w3id.org/vc/status-list#statusPurpose",
                statusListIndex: "https://w3id.org/vc/status-list#statusListIndex",
                statusListCredential: {
                    "@id": "https://w3id.org/vc/status-list#statusListCredential",
                    "@type": "@id",
                },
            },
        },
    },
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const contextDefinitions = {
    "https://www.w3.org/2018/credentials/v1": VC,
    "https://schema.inrupt.com/credentials/v1.jsonld": Inrupt,
};
const cachedContexts = {
    "https://vc.inrupt.com/credentials/v1": vc,
    "https://w3id.org/security/data-integrity/v1": integrity,
    "https://w3id.org/vc-revocation-list-2020/v1": revocation,
    "https://w3id.org/vc/status-list/2021/v1": statusList,
    "https://w3id.org/security/suites/ed25519-2020/v1": ed25519,
};

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/* eslint-disable max-classes-per-file */
/**
 * A JSON-LD document loader with the standard context for VCs pre-loaded
 */
class CachedFetchDocumentLoader extends jsonldContextParser.FetchDocumentLoader {
    constructor(contexts, allowContextFetching = false, ...args) {
        var _a;
        super((_a = args[0]) !== null && _a !== void 0 ? _a : fetch);
        this.allowContextFetching = allowContextFetching;
        this.contexts = { ...contexts, ...cachedContexts, ...contextDefinitions };
    }
    async load(url) {
        if (Object.keys(this.contexts).includes(url)) {
            return this.contexts[url];
        }
        if (!this.allowContextFetching) {
            throw new Error(`Unexpected context requested [${url}]`);
        }
        return super.load(url);
    }
}
function hashOptions(options) {
    const opts = { ...options, parentContext: undefined };
    for (const key of Object.keys(opts)) {
        if (typeof opts[key] === "undefined") {
            delete opts[key];
        }
    }
    return md5(JSON.stringify(opts, Object.keys(opts).sort()));
}
function hashContext(context, cmap) {
    if (Array.isArray(context)) {
        return md5(JSON.stringify(context.map((c) => (typeof c === "string" ? c : cmap(c)))));
    }
    return typeof context === "string" ? md5(context) : cmap(context).toString();
}
// This is a workaround until https://github.com/rubensworks/jsonld-context-parser.js/pull/70 is closed
class CachingContextParser extends jsonldContextParser.ContextParser {
    constructor() {
        super(...arguments);
        this.cachedParsing = {};
        this.contextMap = new Map();
        this.contextHashMap = new Map();
        this.mapIndex = 1;
        this.cmap = (context) => {
            if (!this.contextMap.has(context)) {
                const hash = md5(JSON.stringify(context));
                if (!this.contextHashMap.has(hash)) {
                    this.contextHashMap.set(hash, (this.mapIndex += 1));
                }
                this.contextMap.set(context, this.contextHashMap.get(hash));
            }
            return this.contextMap.get(context);
        };
    }
    async parse(context, options) {
        var _a;
        var _b, _c;
        let hash = hashOptions(options);
        if ((options === null || options === void 0 ? void 0 : options.parentContext) &&
            Object.keys(options.parentContext).length !== 0) {
            hash = md5(hash + this.cmap(options.parentContext));
        }
        // eslint-disable-next-line no-return-assign
        return ((_a = (_b = this.cachedParsing)[_c = md5(hash + hashContext(context, this.cmap))]) !== null && _a !== void 0 ? _a : (_b[_c] = super.parse(context, options)));
    }
}
let reusableDocumentLoader;
let reusableContextParser;
/**
 * Our internal JsonLd Parser with a cached VC context
 */
class CachedJsonLdParser extends jsonldStreamingParser.JsonLdParser {
    constructor(options) {
        let documentLoader;
        if (!(options === null || options === void 0 ? void 0 : options.contexts) && !(options === null || options === void 0 ? void 0 : options.allowContextFetching)) {
            reusableDocumentLoader !== null && reusableDocumentLoader !== void 0 ? reusableDocumentLoader : (reusableDocumentLoader = new CachedFetchDocumentLoader(undefined, undefined, fetch));
            documentLoader = reusableDocumentLoader;
        }
        else {
            documentLoader = new CachedFetchDocumentLoader(options.contexts, options.allowContextFetching, fetch);
        }
        super({
            documentLoader,
            baseIRI: options === null || options === void 0 ? void 0 : options.baseIRI,
        });
        if (!(options === null || options === void 0 ? void 0 : options.contexts) && !(options === null || options === void 0 ? void 0 : options.allowContextFetching)) {
            reusableContextParser !== null && reusableContextParser !== void 0 ? reusableContextParser : (reusableContextParser = new CachingContextParser({
                documentLoader: reusableDocumentLoader,
            }));
            // @ts-expect-error parsingContext is an internal property
            this.parsingContext.contextParser = reusableContextParser;
        }
    }
}
/**
 * Gets an N3 store from a JSON-LD string
 * @param response A JSON-LD string
 * @param options An optional fetch function for dereferencing remote contexts
 * @returns A store containing the Quads in the JSON-LD response
 */
async function jsonLdStringToStore(data, options) {
    const parser = new CachedJsonLdParser(options);
    const store = new n3.Store();
    const storePromise = eventEmitterPromisify.promisifyEventEmitter(store.import(parser), store);
    parser.write(data);
    parser.end();
    return storePromise;
}
/**
 * Gets an N3 store from a JSON-LD as an Object
 * @param response JSON-LD as an Object
 * @param options An optional fetch function for dereferencing remote contexts
 * @returns A store containing the Quads in the JSON-LD response
 */
function jsonLdToStore(data, options) {
    return jsonLdStringToStore(JSON.stringify(data), options);
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const { namedNode: namedNode$4 } = n3.DataFactory;
const SEC = "https://w3id.org/security#";
const CRED = "https://www.w3.org/2018/credentials#";
const XSD = "http://www.w3.org/2001/XMLSchema#";
const DC = "http://purl.org/dc/terms/";
const rdf = {
    type: namedNode$4(rdfNamespaces.rdf.type),
};
const xsd = {
    boolean: namedNode$4(`${XSD}boolean`),
    dateTime: namedNode$4(`${XSD}dateTime`),
};
const cred = {
    issuanceDate: namedNode$4(`${CRED}issuanceDate`),
    expirationDate: namedNode$4(`${CRED}expirationDate`),
    issuer: namedNode$4(`${CRED}issuer`),
    credentialSubject: namedNode$4(`${CRED}credentialSubject`),
    verifiableCredential: namedNode$4(`${CRED}verifiableCredential`),
    holder: namedNode$4(`${CRED}holder`),
    VerifiableCredential: namedNode$4(`${CRED}VerifiableCredential`),
    VerifiablePresentation: namedNode$4(`${CRED}VerifiablePresentation`),
};
const sec = {
    proof: namedNode$4(`${SEC}proof`),
    proofPurpose: namedNode$4(`${SEC}proofPurpose`),
    proofValue: namedNode$4(`${SEC}proofValue`),
    verificationMethod: namedNode$4(`${SEC}verificationMethod`),
};
const dc = {
    created: namedNode$4(`${DC}created`),
};

const { defaultGraph: defaultGraph$3 } = n3.DataFactory;
function getSingleObject(vc, subject, predicate, type) {
    const results = [...vc.match(subject, predicate, null, defaultGraph$3())];
    if (results.length !== 1) {
        throw new Error(`Expected exactly one result. Found ${results.length}.`);
    }
    const [{ object }] = results;
    const expectedTypes = [type];
    if (!expectedTypes.includes(object.termType)) {
        throw new Error(`Expected [${object.value}] to be a ${expectedTypes.join(" or ")}. Found [${object.termType}]`);
    }
    return object;
}
/**
 * @internal
 */
function lenientSingle(dataset, termTypes = ["NamedNode", "BlankNode"]) {
    const array = [...dataset];
    return array.length === 1 && termTypes.includes(array[0].object.termType)
        ? array[0].object
        : undefined;
}

const { namedNode: namedNode$3, defaultGraph: defaultGraph$2 } = n3.DataFactory;
/**
 * Get the ID (URL) of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const id = getId(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The VC ID URL
 */
function getId(vc) {
    return vc.id;
}
/**
 * Get the subject of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const subject = getCredentialSubject(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The VC subject
 */
function getCredentialSubject(vc) {
    return getSingleObject(vc, namedNode$3(getId(vc)), cred.credentialSubject, "NamedNode");
}
/**
 * Get the issuer of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const issuer = getIssuer(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The VC issuer
 */
function getIssuer(vc) {
    return getSingleObject(vc, namedNode$3(getId(vc)), cred.issuer, "NamedNode")
        .value;
}
/**
 * @internal
 */
function wrapDate(date) {
    if (!date.datatype.equals(namedNode$3("http://www.w3.org/2001/XMLSchema#dateTime"))) {
        throw new Error(`Expected date to be a dateTime; recieved [${date.datatype.value}]`);
    }
    if (Number.isNaN(Date.parse(date.value))) {
        throw new Error(`Found invalid value for date: [${date.value}]`);
    }
    return new Date(date.value);
}
/**
 * Get the issuance date of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const date = getIssuanceDate(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The issuance date
 */
function getIssuanceDate(vc) {
    return wrapDate(getSingleObject(vc, namedNode$3(getId(vc)), cred.issuanceDate, "Literal"));
}
/**
 * Get the expiration date of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const date = getExpirationDate(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The expiration date, or undefined if none is found.
 */
function getExpirationDate(vc) {
    const res = [
        ...vc.match(namedNode$3(getId(vc)), cred.expirationDate, undefined, defaultGraph$2()),
    ];
    if (res.length === 0)
        return undefined;
    if (res.length !== 1)
        throw new Error(`Expected 0 or 1 expiration date. Found ${res.length}.`);
    if (res[0].object.termType !== "Literal")
        throw new Error(`Expected expiration date to be a Literal. Found [${res[0].object.value}] of type [${res[0].object.termType}].`);
    return wrapDate(res[0].object);
}
/**
 * @internal
 */
function isDate(literal) {
    return (!!literal &&
        literal.datatype.equals(xsd.dateTime) &&
        !Number.isNaN(Date.parse(literal.value)));
}
function isValidProof(dataset, proof) {
    return (isDate(lenientSingle(dataset.match(null, dc.created, null, proof), [
        "Literal",
    ])) &&
        lenientSingle(dataset.match(null, sec.proofValue, null, proof), [
            "Literal",
        ]) !== undefined &&
        lenientSingle(dataset.match(null, sec.proofPurpose, null, proof), ["NamedNode"]) !== undefined &&
        lenientSingle(dataset.match(null, sec.verificationMethod, null, proof), ["NamedNode"]) !== undefined &&
        lenientSingle(dataset.match(null, rdf.type, null, proof), [
            "NamedNode",
        ]) !== undefined);
}

const { defaultGraph: defaultGraph$1, quad } = n3.DataFactory;
/**
 * Verifies that a given JSON-LD payload conforms to the Verifiable Credential
 * schema we expect.
 * @param data The JSON-LD payload as an RDFJS dataset
 * @param id The id of the VerifiableCredential as a Named Node
 * @returns true is the payload matches our expectation.
 * @deprecated Use isRdfjsVerifiableCredential instead
 */
function isRdfjsVerifiableCredential(dataset, id) {
    const proof = lenientSingle(dataset.match(id, sec.proof, null, defaultGraph$1()));
    return (!!proof &&
        isValidProof(dataset, proof) &&
        !!lenientSingle(dataset.match(id, cred.issuer, null, defaultGraph$1()), ["NamedNode"]) &&
        isDate(lenientSingle(dataset.match(id, cred.issuanceDate, null, defaultGraph$1()), ["Literal"])) &&
        !!lenientSingle(dataset.match(id, cred.credentialSubject, null, defaultGraph$1()), ["NamedNode"]) &&
        dataset.has(quad(id, rdf.type, cred.VerifiableCredential, defaultGraph$1())));
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const { namedNode: namedNode$2 } = n3.DataFactory;
function isUnknownObject(x) {
    return x !== null && typeof x === "object";
}
function hasProof(x) {
    return x.proof !== null && typeof x.proof === "object";
}
/**
 * This function is a temporary stopgap until we implement proper JSON-LD parsing.
 * It refactors know misalignments between the JSON-LD object we receive and the
 * JSON frame we expect.
 *
 * @param vcJson A JSON-LD VC.
 * @returns an equivalent JSON-LD VC, fitted to a specific frame.
 */
function normalizeVc(vcJson) {
    if (!isUnknownObject(vcJson) || !hasProof(vcJson)) {
        // The received JSON doesn't have the shape we want to refactor
        return vcJson;
    }
    const normalized = { ...vcJson };
    if (typeof vcJson.proof["https://w3id.org/security#proofValue"] === "string") {
        normalized.proof.proofValue =
            vcJson.proof["https://w3id.org/security#proofValue"];
        delete normalized.proof["https://w3id.org/security#proofValue"];
    }
    return normalized;
}
function hasCredentials(x) {
    return (x.verifiableCredential !== null && Array.isArray(x.verifiableCredential));
}
/**
 * Normalizes all VCs wrapped in a VP.
 *
 * @param vpJson A JSON-LD VP.
 * @returns An equivalent JSON-LD VP, with its contained VCs fitted to a specific frame.
 */
function normalizeVp(vpJson) {
    if (!isUnknownObject(vpJson) || !hasCredentials(vpJson)) {
        // The received JSON doesn't have the shape we want to refactor
        return vpJson;
    }
    const normalizedVp = { ...vpJson };
    normalizedVp.verifiableCredential =
        normalizedVp.verifiableCredential.map(normalizeVc);
    return normalizedVp;
}
/**
 * Verifies that a given JSON-LD payload conforms to the Verifiable Credential
 * schema we expect.
 * @param data The JSON-LD payload
 * @returns true is the payload matches our expectation.
 * @deprecated Use isRdfjsVerifiableCredential instead
 */
function isVerifiableCredential(data) {
    let dataIsVc = true;
    dataIsVc = typeof data.id === "string";
    dataIsVc = dataIsVc && Array.isArray(data.type);
    dataIsVc =
        dataIsVc && typeof data.issuer === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.issuanceDate === "string";
    dataIsVc =
        dataIsVc &&
            !Number.isNaN(Date.parse(data.issuanceDate));
    dataIsVc =
        dataIsVc &&
            typeof data.credentialSubject === "object";
    dataIsVc =
        dataIsVc &&
            typeof data.credentialSubject.id === "string";
    dataIsVc =
        dataIsVc && typeof data.proof === "object";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.created === "string";
    dataIsVc =
        dataIsVc &&
            !Number.isNaN(Date.parse(data.proof.created));
    dataIsVc =
        dataIsVc &&
            typeof data.proof.proofPurpose === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.proofValue === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.type === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.verificationMethod ===
                "string";
    return dataIsVc;
}
function isUrl(url) {
    try {
        // If url is not URL-shaped, this will throw.
        // eslint-disable-next-line no-new
        new URL(url);
        return true;
    }
    catch (_e) {
        return false;
    }
}
/**
 * @deprecated Use isRdfjsVerifiableCredential instead
 */
function isVerifiablePresentation(vp) {
    let inputIsVp = true;
    inputIsVp =
        inputIsVp &&
            (Array.isArray(vp.type) ||
                typeof vp.type === "string");
    if (vp.verifiableCredential !== undefined) {
        inputIsVp =
            inputIsVp &&
                Array.isArray(vp.verifiableCredential);
        inputIsVp =
            inputIsVp &&
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                vp.verifiableCredential.every(isVerifiableCredential);
    }
    if (vp.holder !== undefined) {
        inputIsVp =
            inputIsVp && typeof vp.holder === "string";
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        inputIsVp = inputIsVp && isUrl(vp.holder);
    }
    // TODO: No type checking is currently implemented for the proof.
    return inputIsVp;
}
function concatenateContexts(...contexts) {
    const result = new Set();
    contexts.forEach((additionalContext) => {
        // Case when the context is an array of IRIs and/or inline contexts
        if (Array.isArray(additionalContext)) {
            additionalContext.forEach((contextEntry) => result.add(contextEntry));
        }
        else if (additionalContext !== null && additionalContext !== undefined) {
            // Case when the context is a single remote URI or a single inline context
            result.add(additionalContext);
        }
    });
    return Array.from(result.values());
}
/**
 * This context contains the required elements to build a valid VC issuance request.
 */
const defaultContext = ["https://www.w3.org/2018/credentials/v1"];
const defaultCredentialTypes = ["VerifiableCredential"];
// Solid VC URIs
const SOLID_VC_NS = "http://www.w3.org/ns/solid/vc#";
const SOLID_VC_DERIVATION_SERVICE = SOLID_VC_NS.concat("derivationService");
const SOLID_VC_ISSUER_SERVICE = SOLID_VC_NS.concat("issuerService");
const SOLID_VC_STATUS_SERVICE = SOLID_VC_NS.concat("statusService");
const SOLID_VC_VERIFIER_SERVICE = SOLID_VC_NS.concat("verifierService");
async function discoverLegacyEndpoints(vcServiceUrl) {
    var _a, _b, _c, _d;
    const wellKnownIri = new URL(".well-known/vc-configuration", vcServiceUrl);
    try {
        const vcConfigData = await solidClient.getSolidDataset(wellKnownIri.href, {
            // The configuration discovery document is only available as JSON-LD.
            parsers: { "application/ld+json": solidClient.getJsonLdParser() },
        });
        // The dataset should have a single blank node subject of all its triples.
        const [wellKnownRootBlankNode] = solidClient.getThingAll(vcConfigData, {
            acceptBlankNodes: true,
        });
        return {
            derivationService: (_a = solidClient.getIri(wellKnownRootBlankNode, SOLID_VC_DERIVATION_SERVICE)) !== null && _a !== void 0 ? _a : undefined,
            issuerService: (_b = solidClient.getIri(wellKnownRootBlankNode, SOLID_VC_ISSUER_SERVICE)) !== null && _b !== void 0 ? _b : undefined,
            statusService: (_c = solidClient.getIri(wellKnownRootBlankNode, SOLID_VC_STATUS_SERVICE)) !== null && _c !== void 0 ? _c : undefined,
            verifierService: (_d = solidClient.getIri(wellKnownRootBlankNode, SOLID_VC_VERIFIER_SERVICE)) !== null && _d !== void 0 ? _d : undefined,
        };
    }
    catch (e) {
        // The target provider may not implement the legacy endpoints, in which case
        // the request above would fail.
        return {};
    }
}
function discoverSpecCompliantEndpoints(vcServiceUrl) {
    return {
        issuerService: new URL("/credentials/issue", vcServiceUrl).toString(),
        issuerCredentialAll: new URL("/credentials", vcServiceUrl).toString(),
        statusService: new URL("/credentials/status", vcServiceUrl).toString(),
        holderPresentationAll: new URL("/presentations", vcServiceUrl).toString(),
        derivationService: new URL("/credentials/derive", vcServiceUrl).toString(),
        exchangeService: new URL("/exchanges", vcServiceUrl).toString(),
        proveService: new URL("/presentations/prove", vcServiceUrl).toString(),
        queryService: new URL("/query", vcServiceUrl).toString(),
        credentialVerifierService: new URL("/credentials/verify", vcServiceUrl).toString(),
        presentationVerifierService: new URL("/presentations/verify", vcServiceUrl).toString(),
    };
}
/**
 * Discover the available services for a given VC service provider. The detail of
 * some of these services are given by the [W3C VC API](https://github.com/w3c-ccg/vc-api/).
 *
 * The returned value has two entries at its top-level, `legacy` and `specCompliant`.
 * The former reflects the legacy (default) behavior, and relies on an ad-hoc discovery
 * mechanism. The latter follows what the VC-API specification requires.
 *
 * Note that since the specification only mandates URL patterns, what the discovery
 * gets you is the URL where the endpoint should be available **if it is present**.
 * Whether it actually is available or not is something you cannot assume and must
 * explicitly check.
 *
 * @example
 * Here is how the spec-compliant endpoints are discovered:
 * ```
 * const config = await getVerifiableCredentialApiConfiguration("https://example.org/vc-provider");
 * const issuer = config.specCompliant.issuerService;
 * ```
 *
 * Here is how legacy endpoints are accessed:
 * ```
 * const config = await getVerifiableCredentialApiConfiguration("https://example.org/vc-provider");
 * const legacyIssuer = config.legacy.issuerService;
 *```
 * @param vcServiceUrl The URL of the VC services provider. Only the domain is relevant, any provided path will be ignored.
 * @returns A map of the services available and their URLs.
 * @since 0.2.0
 */
async function getVerifiableCredentialApiConfiguration(vcServiceUrl) {
    const legacyEndpoints = await discoverLegacyEndpoints(vcServiceUrl.toString());
    const specEndpoints = discoverSpecCompliantEndpoints(vcServiceUrl.toString());
    return {
        ...legacyEndpoints,
        legacy: legacyEndpoints,
        specCompliant: specEndpoints,
    };
}
// eslint-disable-next-line camelcase
function internal_applyDataset(vc, store, options) {
    return Object.freeze({
        ...((options === null || options === void 0 ? void 0 : options.requireId) !== false && { id: vc.id }),
        ...((options === null || options === void 0 ? void 0 : options.includeVcProperties) && vc),
        ...options === null || options === void 0 ? void 0 : options.additionalProperties,
        // Make this a DatasetCore without polluting the object with
        // all of the properties present in the N3.Store
        [Symbol.iterator]() {
            return store[Symbol.iterator]();
        },
        has(quad) {
            return store.has(quad);
        },
        match(...args) {
            return store.match(...args);
        },
        add() {
            throw new Error("Cannot mutate this dataset");
        },
        delete() {
            throw new Error("Cannot mutate this dataset");
        },
        get size() {
            return store.size;
        },
        // For backwards compatibility the dataset properties
        // SHOULD NOT be included when we JSON.stringify the object
        toJSON() {
            return vc;
        },
    });
}
async function verifiableCredentialToDataset(vc, options) {
    let store;
    try {
        store = await jsonLdToStore(vc, options);
    }
    catch (e) {
        throw new Error(`Parsing the Verifiable Credential as JSON-LD failed: ${e}`);
    }
    if ((options === null || options === void 0 ? void 0 : options.requireId) !== false && typeof vc.id !== "string") {
        throw new Error(`Expected vc.id to be a string, found [${vc.id}] of type [${typeof vc.id}] on ${JSON.stringify(vc, null, 2)}`);
    }
    return internal_applyDataset(vc, store, options);
}
function hasId(vc) {
    return (typeof vc === "object" &&
        vc !== null &&
        typeof vc.id === "string");
}
async function internal_getVerifiableCredentialFromResponse(vcUrlInput, response, options) {
    const returnLegacy = (options === null || options === void 0 ? void 0 : options.returnLegacyJsonld) !== false;
    let vc;
    let vcUrl = vcUrlInput;
    try {
        vc = await response.json();
        if (typeof vcUrl !== "string") {
            if (!isUnknownObject(vc) || !("id" in vc) || typeof vc.id !== "string") {
                throw new Error("Cannot establish id of verifiable credential");
            }
            vcUrl = vc.id;
        }
        // If you're wondering why this is not inside the if (returnLegacy) condition outside this try/catch statement
        // see https://github.com/inrupt/solid-client-vc-js/pull/849#discussion_r1405853022
        if (returnLegacy) {
            vc = normalizeVc(vc);
        }
    }
    catch (e) {
        throw new Error(`Parsing the Verifiable Credential [${vcUrl}] as JSON failed: ${e}`);
    }
    if (returnLegacy) {
        if (!(options === null || options === void 0 ? void 0 : options.skipValidation) && !isVerifiableCredential(vc)) {
            throw new Error(`The value received from [${vcUrl}] is not a Verifiable Credential`);
        }
        if (options === null || options === void 0 ? void 0 : options.normalize) {
            vc = options.normalize(vc);
        }
        return verifiableCredentialToDataset(vc, {
            allowContextFetching: options === null || options === void 0 ? void 0 : options.allowContextFetching,
            baseIRI: options === null || options === void 0 ? void 0 : options.baseIRI,
            contexts: options === null || options === void 0 ? void 0 : options.contexts,
            includeVcProperties: true,
        });
    }
    if (!hasId(vc)) {
        throw new Error("Verifiable credential is not an object, or does not have an id");
    }
    const parsedVc = await verifiableCredentialToDataset(vc, {
        allowContextFetching: options.allowContextFetching,
        baseIRI: options.baseIRI,
        contexts: options.contexts,
        includeVcProperties: false,
    });
    if (!options.skipValidation &&
        !isRdfjsVerifiableCredential(parsedVc, namedNode$2(parsedVc.id))) {
        throw new Error(`The value received from [${vcUrl}] is not a Verifiable Credential`);
    }
    return parsedVc;
}
async function getVerifiableCredential(vcUrl, options) {
    var _a;
    const authFetch = (_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch;
    const response = await authFetch(vcUrl);
    if (!response.ok) {
        throw new Error(`Fetching the Verifiable Credential [${vcUrl}] failed: ${response.status} ${response.statusText}`);
    }
    return internal_getVerifiableCredentialFromResponse(vcUrl, response, options);
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
async function issueVerifiableCredential(issuerEndpoint, subjectClaims, credentialClaims, options) {
    const internalOptions = { ...options };
    if (internalOptions.fetch === undefined) {
        internalOptions.fetch = fetch;
    }
    // credentialClaims should contain all the claims, but not the context.
    const { "@context": subjectClaimsContext, ...contextlessSubjectClaims } = subjectClaims;
    // When we add proper JSONLD parsing support, the following should be replaced.
    const { "@context": credentialClaimsContext, ...contextlessCredentialClaims } = credentialClaims !== undefined ? credentialClaims : { "@context": [] };
    const { type: credentialTypeClaims, ...nonTypeCredentialClaims } = contextlessCredentialClaims;
    let credentialTypes = [];
    if (credentialTypeClaims !== undefined) {
        credentialTypes = Array.isArray(credentialTypeClaims)
            ? credentialTypeClaims
            : [credentialTypeClaims];
    }
    const credentialIssueBody = {
        // See https://w3c-ccg.github.io/vc-api/issuer.html
        credential: {
            "@context": concatenateContexts(defaultContext, subjectClaimsContext, credentialClaimsContext),
            type: [...defaultCredentialTypes, ...credentialTypes],
            ...nonTypeCredentialClaims,
            credentialSubject: contextlessSubjectClaims,
        },
    };
    const response = await internalOptions.fetch(issuerEndpoint, {
        headers: {
            "Content-Type": "application/json",
        },
        method: "POST",
        body: JSON.stringify(credentialIssueBody),
    });
    if (!response.ok) {
        // TODO: use the error library when available.
        throw new Error(`The VC issuing endpoint [${issuerEndpoint}] could not successfully issue a VC: ${response.status} ${response.statusText}`);
    }
    return internal_getVerifiableCredentialFromResponse(undefined, response, options);
}

const { defaultGraph } = n3.DataFactory;
function getHolder(dataset, id) {
    const holder = [...dataset.match(id, cred.holder, null, defaultGraph())];
    if (holder.length === 1 &&
        holder[0].object.termType === "NamedNode" &&
        isUrl(holder[0].object.value)) {
        return holder[0].object.value;
    }
    throw new Error("Could not find a valid holder");
}
function getVpSubject(data) {
    const presentations = [
        ...data.match(null, rdf.type, cred.VerifiablePresentation, defaultGraph()),
    ];
    if (presentations.length !== 1) {
        throw new Error(`Expected exactly one Verifiable Presentation. Found ${presentations.length}.`);
    }
    const { subject } = presentations[0];
    if (subject.termType !== "BlankNode" && subject.termType !== "NamedNode") {
        throw new Error(`Expected VP subject to be NamedNode or BlankNode. Instead found [${subject.value}] with termType [${subject.termType}]`);
    }
    return subject;
}
function isRdfjsVerifiablePresentation(dataset, id) {
    for (const { object } of dataset.match(id, cred.verifiableCredential, null, defaultGraph())) {
        if (object.termType !== "NamedNode" ||
            !isRdfjsVerifiableCredential(dataset, object)) {
            return false;
        }
    }
    const holder = [...dataset.match(id, cred.holder, null, defaultGraph())];
    return ((holder.length === 0 ||
        (holder.length === 1 &&
            holder[0].object.termType === "NamedNode" &&
            isUrl(holder[0].object.value))) &&
        // dataset.has(quad(id, rdf.type, cred.VerifiablePresentation, defaultGraph()))
        // FIXME: Replace with the above condition
        dataset.match(id, rdf.type, null, defaultGraph()).size >= 1);
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const { namedNode: namedNode$1 } = n3.DataFactory;
async function query(queryEndpoint, vpRequest, options = {}) {
    const internalOptions = { ...options };
    if (internalOptions.fetch === undefined) {
        internalOptions.fetch = fetch;
    }
    const response = await internalOptions.fetch(queryEndpoint, {
        headers: {
            "Content-Type": "application/json",
        },
        method: "POST",
        body: JSON.stringify(vpRequest),
    });
    if (!response.ok) {
        throw new Error(`The query endpoint [${queryEndpoint}] returned an error: ${response.status} ${response.statusText}`);
    }
    // Return to this approach once https://github.com/rubensworks/jsonld-streaming-parser.js/issues/122 is resolved
    // if (options?.returnLegacyJsonld === false) {
    //   try {
    //     const vpJson = await response.json();
    //     console.log(JSON.stringify(vpJson, null, 2), null, 2)
    //     const store = await jsonLdToStore(vpJson);
    //     const vp = [...store.match(null, rdf.type, cred.VerifiablePresentation, defaultGraph())]
    //     if (vp.length !== 1) {
    //       throw new Error(`Expected exactly 1 Verifiable Presentation. Found ${vp.length}.`)
    //     }
    //     const [{ subject }] = vp;
    //     if (subject.termType !== 'BlankNode' && subject.termType !== 'NamedNode') {
    //       throw new Error(`Expected VP to be a Blank Node or Named Node. Found [${subject.value}] of type [${subject.termType}].`)
    //     }
    //     if (!isRdfjsVerifiablePresentation(store, subject)) {
    //       throw new Error(
    //         `The holder [${queryEndpoint}] did not return a Verifiable Presentation: ${JSON.stringify(
    //           vpJson, null, 2
    //         )}`,
    //       );
    //     }
    //     // In the future we want to get rid of this and get the verifiableCredential ids from the store
    //     // the reason we need this for now is because we need the verifiableCredential JSON object for
    //     // the toJSON method.
    //     const verifiableCredential: DatasetWithId[] = vpJson.verifiableCredential.map((vc: unknown) => {
    //       if (vc === null || typeof vc !== 'object') {
    //         throw new Error(`Verifiable Credential entry is not an object`);
    //       }
    //       if (!('id' in vc) || typeof vc.id !== 'string') {
    //         throw new Error(`Verifiable credential is missing a string id`);
    //       }
    //       const c = internal_applyDataset(vc as { id: string }, store, options)
    //       if (!isRdfjsVerifiableCredential(store, namedNode(c.id))) {
    //         throw new Error(`[${c.id}] is not a valid Verifiable Credential`);
    //       }
    //     });
    //     return internal_applyDataset(vpJson, store, {
    //       ...options,
    //       additionalProperties: {
    //         verifiableCredential
    //       }
    //     });
    //   } catch (e) {
    //     throw new Error(
    //       `The holder [${queryEndpoint}] did not return a valid JSON response: parsing failed with error ${e}`,
    //     );
    //   }
    // }
    // All code below here should is deprecated
    let data;
    let rawData;
    try {
        rawData = await response.json();
        if (options.returnLegacyJsonld !== false) {
            rawData = normalizeVp(rawData);
        }
        data = (await verifiableCredentialToDataset(rawData, {
            includeVcProperties: options.returnLegacyJsonld !== false,
            additionalProperties: typeof rawData.id === "string" ? { id: rawData.id } : {},
            requireId: false,
            // This is a lie depending on how returnLegacyJsonld is set
        }));
    }
    catch (e) {
        throw new Error(`The holder [${queryEndpoint}] did not return a valid JSON response: parsing failed with error ${e}`);
    }
    const subject = typeof data.id === "string" ? namedNode$1(data.id) : getVpSubject(data);
    if (options.returnLegacyJsonld === false
        ? !isRdfjsVerifiablePresentation(data, subject)
        : !isVerifiablePresentation(data)) {
        throw new Error(`The holder [${queryEndpoint}] did not return a Verifiable Presentation: ${JSON.stringify(data)}`);
    }
    const newVerifiableCredential = [];
    if (rawData.verifiableCredential &&
        Array.isArray(rawData.verifiableCredential)) {
        for (let i = 0; i < rawData.verifiableCredential.length; i += 100) {
            newVerifiableCredential.push(
            // Limit concurrency to avoid memory overflows. For details see
            // https://github.com/inrupt/solid-client-vc-js/pull/849#discussion_r1377400688
            // eslint-disable-next-line no-await-in-loop
            ...(await Promise.all(rawData.verifiableCredential
                .slice(i, i + 100)
                .map(async (_vc) => {
                let vc = _vc;
                if (typeof vc !== "object" || vc === null) {
                    throw new Error(`Verifiable Credentail is an invalid object`);
                }
                if (options.normalize) {
                    vc = options.normalize(vc);
                }
                const res = await verifiableCredentialToDataset(vc, {
                    ...options,
                    includeVcProperties: options.returnLegacyJsonld !== false,
                });
                if (!isRdfjsVerifiableCredential(res, namedNode$1(res.id))) {
                    throw new Error(`[${res.id}] is not a Valid Verifiable Credential`);
                }
                return res;
            }))));
        }
    }
    return {
        ...data,
        verifiableCredential: newVerifiableCredential,
    };
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const INCLUDE_EXPIRED_VC_OPTION = "ExpiredVerifiableCredential";
/**
 * This creates the proprietary data structure used for querying the legacy /derive
 * endpoint of ESS.
 *
 * @param vcShape The VC example used for the VP request
 * @param includeExpiredVc An option to query for expired VC as well
 * @returns A legacy object expected by the /derive endpoint of the ESS 2.0 VC service
 */
function buildLegacyQuery(vcShape, includeExpiredVc) {
    // credentialClaims should contain all the claims, but not the context.
    const { "@context": claimsContext, ...credentialClaims } = vcShape;
    return {
        // See https://w3c-ccg.github.io/vc-api/holder.html
        verifiableCredential: {
            "@context": concatenateContexts(defaultContext, claimsContext),
            ...credentialClaims,
        },
        options: {
            include: includeExpiredVc ? INCLUDE_EXPIRED_VC_OPTION : undefined,
        },
    };
}
/**
 * See https://w3c-ccg.github.io/vp-request-spec/#query-by-example.
 * @param vcShape The VC example used for the VP request
 * @returns A Query by Example VP Request based on the provided example.
 */
function buildQueryByExample(vcShape) {
    return {
        query: [
            {
                type: "QueryByExample",
                credentialQuery: [
                    {
                        example: vcShape,
                    },
                ],
            },
        ],
    };
}
async function getVerifiableCredentialAllFromShape(holderEndpoint, vcShape, options) {
    var _a, _b;
    const fetchFn = (_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch;
    // The request payload depends on the target endpoint.
    const vpRequest = holderEndpoint.endsWith("/query")
        ? // The target endpoint is spec-compliant, and uses a standard VP request.
            // This is based on an implementation-specific assumption about the endpoint
            // being available under the /query path.
            buildQueryByExample(vcShape)
        : // The target endpoint is legacy, and uses a proprietary request format.
            buildLegacyQuery(vcShape, (_b = options === null || options === void 0 ? void 0 : options.includeExpiredVc) !== null && _b !== void 0 ? _b : false);
    const vp = await query(holderEndpoint, vpRequest, {
        fetch: fetchFn,
        returnLegacyJsonld: options === null || options === void 0 ? void 0 : options.returnLegacyJsonld,
        normalize: options === null || options === void 0 ? void 0 : options.normalize,
    });
    return vp.verifiableCredential;
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/**
 * Revoke a given VC from a given issuer. This changes the status of the VC so that
 * subsequent verifications will fail. The issuer is expected to implement the
 * [W3C VC Issuer HTTP API](https://w3c-ccg.github.io/vc-api/issuer.html),
 * in particular [VC status update](https://w3c-ccg.github.io/vc-api/issuer.html#operation/updateCredentialStatus).
 *
 * @param issuerEndpoint The `/status` endpoint of the holder.
 * @param credentialId The identifier of the VC to be revoked.
 * @param options Optional parameter `options.fetch`: An alternative `fetch` function to make the HTTP request, compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
 * This can be typically used for authentication. Note that if it is omitted, and
 * `@inrupt/solid-client-authn-browser` is in your dependencies, the default session
 * is picked up.
 * @since 0.1.0
 */
async function revokeVerifiableCredential(issuerEndpoint, credentialId, options) {
    const internalOptions = { ...options };
    if (internalOptions.fetch === undefined) {
        internalOptions.fetch = fetch;
    }
    const response = await internalOptions.fetch(issuerEndpoint, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            credentialId,
            credentialStatus: [
                {
                    type: "RevocationList2020Status",
                    status: "1",
                },
            ],
        }),
    });
    if (!response.ok) {
        throw new Error(`The issuer [${issuerEndpoint}] returned an error: ${response.status} ${response.statusText}`);
    }
}

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const { namedNode } = n3.DataFactory;
async function dereferenceVc(vc, options) {
    // This test passes for both URL and UrlString
    if (!vc.toString().startsWith("http")) {
        if (typeof vc.match === "function") {
            return vc;
        }
        return verifiableCredentialToDataset(vc, {
            requireId: true,
        });
    }
    return getVerifiableCredential(vc.toString(), options);
}
/**
 * Verify that a VC is valid, i.e. :
 * - its signature matches its issuer's key
 * - it has not been revoked
 * - it isn't expired
 * These verifications are done server-side by a Verification Service, either
 * discovered from the VC Issuer or manually provided.
 *
 * @param vc The VC to verify
 * @param options Additional options
 * - `options.fetch`: An alternative `fetch` function to make the HTTP request,
 * compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
 * This can be typically used for authentication.
 * - `options.verificationEndpoint`: Pass a trusted VC verification service
 *
 * @returns a JSON-shaped validation report structured accoring to the [VC Verifier API](https://w3c-ccg.github.io/vc-api/verifier.html#operation/verifyCredential).
 * @since 0.3.0
 */
async function isValidVc(vc, options) {
    var _a, _b;
    const fetcher = (_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch;
    const vcObject = await dereferenceVc(vc, options);
    if (!hasId(vcObject) ||
        !isRdfjsVerifiableCredential(vcObject, namedNode(getId(vcObject)))) {
        throw new Error(`The request to [${vc}] returned an unexpected response: ${JSON.stringify(vcObject, null, "  ")}`);
    }
    // Discover the consent endpoint from the resource part of the Access Grant.
    const verifierEndpoint = (_b = options === null || options === void 0 ? void 0 : options.verificationEndpoint) !== null && _b !== void 0 ? _b : (await getVerifiableCredentialApiConfiguration(getIssuer(vcObject)))
        .verifierService;
    if (verifierEndpoint === undefined) {
        throw new Error(`The VC service provider ${getIssuer(vcObject)} does not advertize for a verifier service in its .well-known/vc-configuration document`);
    }
    const response = await fetcher(verifierEndpoint, {
        headers: {
            "Content-Type": "application/json",
        },
        method: "POST",
        body: JSON.stringify({
            verifiableCredential: vcObject,
        }),
    });
    if (!response.ok) {
        throw new Error(`The request to the verification endpoint [${verifierEndpoint}] failed: ${response.status} ${response.statusText}`);
    }
    try {
        return await response.json();
    }
    catch (e) {
        throw new Error(`Parsing the response of the verification service hosted at [${verifierEndpoint}] as JSON failed: ${
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        e.toString()}`);
    }
}
async function asDataset(data, requireId) {
    return typeof data.match === "function"
        ? data
        : verifiableCredentialToDataset(data, {
            requireId,
        });
}
/**
 * Verify that a VP is valid and content has not ben tampered with.
 *
 * @param verificationEndpoint The verification endpoint
 * @param verifiablePresentation The VP to verify
 * @param options Additional options
 * - `options.fetch`: An alternative `fetch` function to make the HTTP request,
 * compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
 * This can be typically used for authentication.
 * - `options.domain`: Pass a domain
 * - `options.challenge`: Pass a challenge
 *
 * @returns a JSON-shaped validation report structured accoring to the [VP Verifier API](https://w3c-ccg.github.io/vc-api/verifier.html#operation/verifyPresentation).
 * @since
 */
async function isValidVerifiablePresentation(verificationEndpoint, verifiablePresentation, options = {}) {
    var _a;
    const fetcher = (_a = options.fetch) !== null && _a !== void 0 ? _a : fetch;
    const dataset = await asDataset(verifiablePresentation, false);
    const subject = getVpSubject(dataset);
    if (!isRdfjsVerifiablePresentation(dataset, subject)) {
        throw new Error(`The request to [${dataset}] returned an unexpected response: ${JSON.stringify(dataset, null, "  ")}`);
    }
    if (verifiablePresentation.verifiableCredential) {
        const datasets = await Promise.all(verifiablePresentation.verifiableCredential.map(async (vc) => {
            const vcDataset = await asDataset(vc, true);
            return isRdfjsVerifiableCredential(vcDataset, namedNode(getId(vcDataset)));
        }));
        if (datasets.some((vc) => vc === false)) {
            throw new Error(`The request to [${dataset}] returned an unexpected response: ${JSON.stringify(dataset, null, "  ")}`);
        }
    }
    const verifierEndpoint = verificationEndpoint !== null && verificationEndpoint !== void 0 ? verificationEndpoint : (await getVerifiableCredentialApiConfiguration(getHolder(dataset, subject)))
        .verifierService;
    if (verifierEndpoint === undefined) {
        throw new Error(`The VC service provider ${getHolder(dataset, subject)} does not advertize for a verifier service in its .well-known/vc-configuration document`);
    }
    const response = await fetcher(verifierEndpoint, {
        headers: {
            "Content-Type": "application/json",
        },
        method: "POST",
        body: JSON.stringify({
            verifiablePresentation: dataset,
            options: {
                domain: options.domain,
                challenge: options.challenge,
            },
        }),
    });
    if (!response.ok) {
        throw new Error(`The request to the verification endpoint [${verificationEndpoint}] failed: ${response.status} ${response.statusText}`);
    }
    try {
        return await response.json();
    }
    catch (e) {
        throw new Error(`Parsing the response of the verification service hosted at [${verificationEndpoint}] as JSON failed: ${
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        e.toString()}`);
    }
}

exports.getCredentialSubject = getCredentialSubject;
exports.getExpirationDate = getExpirationDate;
exports.getId = getId;
exports.getIssuanceDate = getIssuanceDate;
exports.getIssuer = getIssuer;
exports.getVerifiableCredential = getVerifiableCredential;
exports.getVerifiableCredentialAllFromShape = getVerifiableCredentialAllFromShape;
exports.getVerifiableCredentialApiConfiguration = getVerifiableCredentialApiConfiguration;
exports.isRdfjsVerifiableCredential = isRdfjsVerifiableCredential;
exports.isRdfjsVerifiablePresentation = isRdfjsVerifiablePresentation;
exports.isValidVc = isValidVc;
exports.isValidVerifiablePresentation = isValidVerifiablePresentation;
exports.isVerifiableCredential = isVerifiableCredential;
exports.isVerifiablePresentation = isVerifiablePresentation;
exports.issueVerifiableCredential = issueVerifiableCredential;
exports.query = query;
exports.revokeVerifiableCredential = revokeVerifiableCredential;
exports.verifiableCredentialToDataset = verifiableCredentialToDataset;
//# sourceMappingURL=index.js.map
