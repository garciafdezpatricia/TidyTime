import { promisifyEventEmitter } from 'event-emitter-promisify';
import { FetchDocumentLoader, ContextParser } from 'jsonld-context-parser';
import { JsonLdParser } from 'jsonld-streaming-parser';
import { Store } from 'n3';
import md5 from 'md5';
import contextDefinitions, { cachedContexts } from './contexts/index.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
/* eslint-disable max-classes-per-file */
/**
 * A JSON-LD document loader with the standard context for VCs pre-loaded
 */
class CachedFetchDocumentLoader extends FetchDocumentLoader {
    constructor(contexts, allowContextFetching = false, ...args) {
        var _a;
        super((_a = args[0]) !== null && _a !== void 0 ? _a : fetch);
        this.allowContextFetching = allowContextFetching;
        this.contexts = { ...contexts, ...cachedContexts, ...contextDefinitions };
    }
    async load(url) {
        if (Object.keys(this.contexts).includes(url)) {
            return this.contexts[url];
        }
        if (!this.allowContextFetching) {
            throw new Error(`Unexpected context requested [${url}]`);
        }
        return super.load(url);
    }
}
function hashOptions(options) {
    const opts = { ...options, parentContext: undefined };
    for (const key of Object.keys(opts)) {
        if (typeof opts[key] === "undefined") {
            delete opts[key];
        }
    }
    return md5(JSON.stringify(opts, Object.keys(opts).sort()));
}
function hashContext(context, cmap) {
    if (Array.isArray(context)) {
        return md5(JSON.stringify(context.map((c) => (typeof c === "string" ? c : cmap(c)))));
    }
    return typeof context === "string" ? md5(context) : cmap(context).toString();
}
// This is a workaround until https://github.com/rubensworks/jsonld-context-parser.js/pull/70 is closed
class CachingContextParser extends ContextParser {
    constructor() {
        super(...arguments);
        this.cachedParsing = {};
        this.contextMap = new Map();
        this.contextHashMap = new Map();
        this.mapIndex = 1;
        this.cmap = (context) => {
            if (!this.contextMap.has(context)) {
                const hash = md5(JSON.stringify(context));
                if (!this.contextHashMap.has(hash)) {
                    this.contextHashMap.set(hash, (this.mapIndex += 1));
                }
                this.contextMap.set(context, this.contextHashMap.get(hash));
            }
            return this.contextMap.get(context);
        };
    }
    async parse(context, options) {
        var _a;
        var _b, _c;
        let hash = hashOptions(options);
        if ((options === null || options === void 0 ? void 0 : options.parentContext) &&
            Object.keys(options.parentContext).length !== 0) {
            hash = md5(hash + this.cmap(options.parentContext));
        }
        // eslint-disable-next-line no-return-assign
        return ((_a = (_b = this.cachedParsing)[_c = md5(hash + hashContext(context, this.cmap))]) !== null && _a !== void 0 ? _a : (_b[_c] = super.parse(context, options)));
    }
}
let reusableDocumentLoader;
let reusableContextParser;
/**
 * Our internal JsonLd Parser with a cached VC context
 */
class CachedJsonLdParser extends JsonLdParser {
    constructor(options) {
        let documentLoader;
        if (!(options === null || options === void 0 ? void 0 : options.contexts) && !(options === null || options === void 0 ? void 0 : options.allowContextFetching)) {
            reusableDocumentLoader !== null && reusableDocumentLoader !== void 0 ? reusableDocumentLoader : (reusableDocumentLoader = new CachedFetchDocumentLoader(undefined, undefined, fetch));
            documentLoader = reusableDocumentLoader;
        }
        else {
            documentLoader = new CachedFetchDocumentLoader(options.contexts, options.allowContextFetching, fetch);
        }
        super({
            documentLoader,
            baseIRI: options === null || options === void 0 ? void 0 : options.baseIRI,
        });
        if (!(options === null || options === void 0 ? void 0 : options.contexts) && !(options === null || options === void 0 ? void 0 : options.allowContextFetching)) {
            reusableContextParser !== null && reusableContextParser !== void 0 ? reusableContextParser : (reusableContextParser = new CachingContextParser({
                documentLoader: reusableDocumentLoader,
            }));
            // @ts-expect-error parsingContext is an internal property
            this.parsingContext.contextParser = reusableContextParser;
        }
    }
}
/**
 * Gets an N3 store from a JSON-LD string
 * @param response A JSON-LD string
 * @param options An optional fetch function for dereferencing remote contexts
 * @returns A store containing the Quads in the JSON-LD response
 */
async function jsonLdStringToStore(data, options) {
    const parser = new CachedJsonLdParser(options);
    const store = new Store();
    const storePromise = promisifyEventEmitter(store.import(parser), store);
    parser.write(data);
    parser.end();
    return storePromise;
}
/**
 * Gets an N3 store from a JSON-LD as an Object
 * @param response JSON-LD as an Object
 * @param options An optional fetch function for dereferencing remote contexts
 * @returns A store containing the Quads in the JSON-LD response
 */
function jsonLdToStore(data, options) {
    return jsonLdStringToStore(JSON.stringify(data), options);
}

export { CachedFetchDocumentLoader, CachedJsonLdParser, CachingContextParser, jsonLdStringToStore, jsonLdToStore };
