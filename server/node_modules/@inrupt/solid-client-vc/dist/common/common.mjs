import { getJsonLdParser, getSolidDataset, getThingAll, getIri } from '@inrupt/solid-client';
import { DataFactory } from 'n3';
import { jsonLdToStore } from '../parser/jsonld.mjs';
import isRdfjsVerifiableCredential from './isRdfjsVerifiableCredential.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
const { namedNode } = DataFactory;
function isUnknownObject(x) {
    return x !== null && typeof x === "object";
}
function hasProof(x) {
    return x.proof !== null && typeof x.proof === "object";
}
/**
 * This function is a temporary stopgap until we implement proper JSON-LD parsing.
 * It refactors know misalignments between the JSON-LD object we receive and the
 * JSON frame we expect.
 *
 * @param vcJson A JSON-LD VC.
 * @returns an equivalent JSON-LD VC, fitted to a specific frame.
 */
function normalizeVc(vcJson) {
    if (!isUnknownObject(vcJson) || !hasProof(vcJson)) {
        // The received JSON doesn't have the shape we want to refactor
        return vcJson;
    }
    const normalized = { ...vcJson };
    if (typeof vcJson.proof["https://w3id.org/security#proofValue"] === "string") {
        normalized.proof.proofValue =
            vcJson.proof["https://w3id.org/security#proofValue"];
        delete normalized.proof["https://w3id.org/security#proofValue"];
    }
    return normalized;
}
function hasCredentials(x) {
    return (x.verifiableCredential !== null && Array.isArray(x.verifiableCredential));
}
/**
 * Normalizes all VCs wrapped in a VP.
 *
 * @param vpJson A JSON-LD VP.
 * @returns An equivalent JSON-LD VP, with its contained VCs fitted to a specific frame.
 */
function normalizeVp(vpJson) {
    if (!isUnknownObject(vpJson) || !hasCredentials(vpJson)) {
        // The received JSON doesn't have the shape we want to refactor
        return vpJson;
    }
    const normalizedVp = { ...vpJson };
    normalizedVp.verifiableCredential =
        normalizedVp.verifiableCredential.map(normalizeVc);
    return normalizedVp;
}
/**
 * Verifies that a given JSON-LD payload conforms to the Verifiable Credential
 * schema we expect.
 * @param data The JSON-LD payload
 * @returns true is the payload matches our expectation.
 * @deprecated Use isRdfjsVerifiableCredential instead
 */
function isVerifiableCredential(data) {
    let dataIsVc = true;
    dataIsVc = typeof data.id === "string";
    dataIsVc = dataIsVc && Array.isArray(data.type);
    dataIsVc =
        dataIsVc && typeof data.issuer === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.issuanceDate === "string";
    dataIsVc =
        dataIsVc &&
            !Number.isNaN(Date.parse(data.issuanceDate));
    dataIsVc =
        dataIsVc &&
            typeof data.credentialSubject === "object";
    dataIsVc =
        dataIsVc &&
            typeof data.credentialSubject.id === "string";
    dataIsVc =
        dataIsVc && typeof data.proof === "object";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.created === "string";
    dataIsVc =
        dataIsVc &&
            !Number.isNaN(Date.parse(data.proof.created));
    dataIsVc =
        dataIsVc &&
            typeof data.proof.proofPurpose === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.proofValue === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.type === "string";
    dataIsVc =
        dataIsVc &&
            typeof data.proof.verificationMethod ===
                "string";
    return dataIsVc;
}
function isUrl(url) {
    try {
        // If url is not URL-shaped, this will throw.
        // eslint-disable-next-line no-new
        new URL(url);
        return true;
    }
    catch (_e) {
        return false;
    }
}
/**
 * @deprecated Use isRdfjsVerifiableCredential instead
 */
function isVerifiablePresentation(vp) {
    let inputIsVp = true;
    inputIsVp =
        inputIsVp &&
            (Array.isArray(vp.type) ||
                typeof vp.type === "string");
    if (vp.verifiableCredential !== undefined) {
        inputIsVp =
            inputIsVp &&
                Array.isArray(vp.verifiableCredential);
        inputIsVp =
            inputIsVp &&
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                vp.verifiableCredential.every(isVerifiableCredential);
    }
    if (vp.holder !== undefined) {
        inputIsVp =
            inputIsVp && typeof vp.holder === "string";
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        inputIsVp = inputIsVp && isUrl(vp.holder);
    }
    // TODO: No type checking is currently implemented for the proof.
    return inputIsVp;
}
function concatenateContexts(...contexts) {
    const result = new Set();
    contexts.forEach((additionalContext) => {
        // Case when the context is an array of IRIs and/or inline contexts
        if (Array.isArray(additionalContext)) {
            additionalContext.forEach((contextEntry) => result.add(contextEntry));
        }
        else if (additionalContext !== null && additionalContext !== undefined) {
            // Case when the context is a single remote URI or a single inline context
            result.add(additionalContext);
        }
    });
    return Array.from(result.values());
}
/**
 * This context contains the required elements to build a valid VC issuance request.
 */
const defaultContext = ["https://www.w3.org/2018/credentials/v1"];
const defaultCredentialTypes = ["VerifiableCredential"];
// Solid VC URIs
const SOLID_VC_NS = "http://www.w3.org/ns/solid/vc#";
const SOLID_VC_DERIVATION_SERVICE = SOLID_VC_NS.concat("derivationService");
const SOLID_VC_ISSUER_SERVICE = SOLID_VC_NS.concat("issuerService");
const SOLID_VC_STATUS_SERVICE = SOLID_VC_NS.concat("statusService");
const SOLID_VC_VERIFIER_SERVICE = SOLID_VC_NS.concat("verifierService");
async function discoverLegacyEndpoints(vcServiceUrl) {
    var _a, _b, _c, _d;
    const wellKnownIri = new URL(".well-known/vc-configuration", vcServiceUrl);
    try {
        const vcConfigData = await getSolidDataset(wellKnownIri.href, {
            // The configuration discovery document is only available as JSON-LD.
            parsers: { "application/ld+json": getJsonLdParser() },
        });
        // The dataset should have a single blank node subject of all its triples.
        const [wellKnownRootBlankNode] = getThingAll(vcConfigData, {
            acceptBlankNodes: true,
        });
        return {
            derivationService: (_a = getIri(wellKnownRootBlankNode, SOLID_VC_DERIVATION_SERVICE)) !== null && _a !== void 0 ? _a : undefined,
            issuerService: (_b = getIri(wellKnownRootBlankNode, SOLID_VC_ISSUER_SERVICE)) !== null && _b !== void 0 ? _b : undefined,
            statusService: (_c = getIri(wellKnownRootBlankNode, SOLID_VC_STATUS_SERVICE)) !== null && _c !== void 0 ? _c : undefined,
            verifierService: (_d = getIri(wellKnownRootBlankNode, SOLID_VC_VERIFIER_SERVICE)) !== null && _d !== void 0 ? _d : undefined,
        };
    }
    catch (e) {
        // The target provider may not implement the legacy endpoints, in which case
        // the request above would fail.
        return {};
    }
}
function discoverSpecCompliantEndpoints(vcServiceUrl) {
    return {
        issuerService: new URL("/credentials/issue", vcServiceUrl).toString(),
        issuerCredentialAll: new URL("/credentials", vcServiceUrl).toString(),
        statusService: new URL("/credentials/status", vcServiceUrl).toString(),
        holderPresentationAll: new URL("/presentations", vcServiceUrl).toString(),
        derivationService: new URL("/credentials/derive", vcServiceUrl).toString(),
        exchangeService: new URL("/exchanges", vcServiceUrl).toString(),
        proveService: new URL("/presentations/prove", vcServiceUrl).toString(),
        queryService: new URL("/query", vcServiceUrl).toString(),
        credentialVerifierService: new URL("/credentials/verify", vcServiceUrl).toString(),
        presentationVerifierService: new URL("/presentations/verify", vcServiceUrl).toString(),
    };
}
/**
 * Discover the available services for a given VC service provider. The detail of
 * some of these services are given by the [W3C VC API](https://github.com/w3c-ccg/vc-api/).
 *
 * The returned value has two entries at its top-level, `legacy` and `specCompliant`.
 * The former reflects the legacy (default) behavior, and relies on an ad-hoc discovery
 * mechanism. The latter follows what the VC-API specification requires.
 *
 * Note that since the specification only mandates URL patterns, what the discovery
 * gets you is the URL where the endpoint should be available **if it is present**.
 * Whether it actually is available or not is something you cannot assume and must
 * explicitly check.
 *
 * @example
 * Here is how the spec-compliant endpoints are discovered:
 * ```
 * const config = await getVerifiableCredentialApiConfiguration("https://example.org/vc-provider");
 * const issuer = config.specCompliant.issuerService;
 * ```
 *
 * Here is how legacy endpoints are accessed:
 * ```
 * const config = await getVerifiableCredentialApiConfiguration("https://example.org/vc-provider");
 * const legacyIssuer = config.legacy.issuerService;
 *```
 * @param vcServiceUrl The URL of the VC services provider. Only the domain is relevant, any provided path will be ignored.
 * @returns A map of the services available and their URLs.
 * @since 0.2.0
 */
async function getVerifiableCredentialApiConfiguration(vcServiceUrl) {
    const legacyEndpoints = await discoverLegacyEndpoints(vcServiceUrl.toString());
    const specEndpoints = discoverSpecCompliantEndpoints(vcServiceUrl.toString());
    return {
        ...legacyEndpoints,
        legacy: legacyEndpoints,
        specCompliant: specEndpoints,
    };
}
// eslint-disable-next-line camelcase
function internal_applyDataset(vc, store, options) {
    return Object.freeze({
        ...((options === null || options === void 0 ? void 0 : options.requireId) !== false && { id: vc.id }),
        ...((options === null || options === void 0 ? void 0 : options.includeVcProperties) && vc),
        ...options === null || options === void 0 ? void 0 : options.additionalProperties,
        // Make this a DatasetCore without polluting the object with
        // all of the properties present in the N3.Store
        [Symbol.iterator]() {
            return store[Symbol.iterator]();
        },
        has(quad) {
            return store.has(quad);
        },
        match(...args) {
            return store.match(...args);
        },
        add() {
            throw new Error("Cannot mutate this dataset");
        },
        delete() {
            throw new Error("Cannot mutate this dataset");
        },
        get size() {
            return store.size;
        },
        // For backwards compatibility the dataset properties
        // SHOULD NOT be included when we JSON.stringify the object
        toJSON() {
            return vc;
        },
    });
}
async function verifiableCredentialToDataset(vc, options) {
    let store;
    try {
        store = await jsonLdToStore(vc, options);
    }
    catch (e) {
        throw new Error(`Parsing the Verifiable Credential as JSON-LD failed: ${e}`);
    }
    if ((options === null || options === void 0 ? void 0 : options.requireId) !== false && typeof vc.id !== "string") {
        throw new Error(`Expected vc.id to be a string, found [${vc.id}] of type [${typeof vc.id}] on ${JSON.stringify(vc, null, 2)}`);
    }
    return internal_applyDataset(vc, store, options);
}
function hasId(vc) {
    return (typeof vc === "object" &&
        vc !== null &&
        typeof vc.id === "string");
}
async function internal_getVerifiableCredentialFromResponse(vcUrlInput, response, options) {
    const returnLegacy = (options === null || options === void 0 ? void 0 : options.returnLegacyJsonld) !== false;
    let vc;
    let vcUrl = vcUrlInput;
    try {
        vc = await response.json();
        if (typeof vcUrl !== "string") {
            if (!isUnknownObject(vc) || !("id" in vc) || typeof vc.id !== "string") {
                throw new Error("Cannot establish id of verifiable credential");
            }
            vcUrl = vc.id;
        }
        // If you're wondering why this is not inside the if (returnLegacy) condition outside this try/catch statement
        // see https://github.com/inrupt/solid-client-vc-js/pull/849#discussion_r1405853022
        if (returnLegacy) {
            vc = normalizeVc(vc);
        }
    }
    catch (e) {
        throw new Error(`Parsing the Verifiable Credential [${vcUrl}] as JSON failed: ${e}`);
    }
    if (returnLegacy) {
        if (!(options === null || options === void 0 ? void 0 : options.skipValidation) && !isVerifiableCredential(vc)) {
            throw new Error(`The value received from [${vcUrl}] is not a Verifiable Credential`);
        }
        if (options === null || options === void 0 ? void 0 : options.normalize) {
            vc = options.normalize(vc);
        }
        return verifiableCredentialToDataset(vc, {
            allowContextFetching: options === null || options === void 0 ? void 0 : options.allowContextFetching,
            baseIRI: options === null || options === void 0 ? void 0 : options.baseIRI,
            contexts: options === null || options === void 0 ? void 0 : options.contexts,
            includeVcProperties: true,
        });
    }
    if (!hasId(vc)) {
        throw new Error("Verifiable credential is not an object, or does not have an id");
    }
    const parsedVc = await verifiableCredentialToDataset(vc, {
        allowContextFetching: options.allowContextFetching,
        baseIRI: options.baseIRI,
        contexts: options.contexts,
        includeVcProperties: false,
    });
    if (!options.skipValidation &&
        !isRdfjsVerifiableCredential(parsedVc, namedNode(parsedVc.id))) {
        throw new Error(`The value received from [${vcUrl}] is not a Verifiable Credential`);
    }
    return parsedVc;
}
async function getVerifiableCredential(vcUrl, options) {
    var _a;
    const authFetch = (_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch;
    const response = await authFetch(vcUrl);
    if (!response.ok) {
        throw new Error(`Fetching the Verifiable Credential [${vcUrl}] failed: ${response.status} ${response.statusText}`);
    }
    return internal_getVerifiableCredentialFromResponse(vcUrl, response, options);
}

export { concatenateContexts, defaultContext, defaultCredentialTypes, getVerifiableCredential, getVerifiableCredentialApiConfiguration, hasId, internal_applyDataset, internal_getVerifiableCredentialFromResponse, isUrl, isVerifiableCredential, isVerifiablePresentation, normalizeVc, normalizeVp, verifiableCredentialToDataset };
