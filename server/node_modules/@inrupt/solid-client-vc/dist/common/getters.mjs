import { DataFactory } from 'n3';
import { cred, xsd, dc, sec, rdf } from './constants.mjs';
import { getSingleObject, lenientSingle } from './rdfjs.mjs';

const { namedNode, defaultGraph } = DataFactory;
/**
 * Get the ID (URL) of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const id = getId(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The VC ID URL
 */
function getId(vc) {
    return vc.id;
}
/**
 * Get the subject of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const subject = getCredentialSubject(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The VC subject
 */
function getCredentialSubject(vc) {
    return getSingleObject(vc, namedNode(getId(vc)), cred.credentialSubject, "NamedNode");
}
/**
 * Get the issuer of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const issuer = getIssuer(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The VC issuer
 */
function getIssuer(vc) {
    return getSingleObject(vc, namedNode(getId(vc)), cred.issuer, "NamedNode")
        .value;
}
/**
 * @internal
 */
function wrapDate(date) {
    if (!date.datatype.equals(namedNode("http://www.w3.org/2001/XMLSchema#dateTime"))) {
        throw new Error(`Expected date to be a dateTime; recieved [${date.datatype.value}]`);
    }
    if (Number.isNaN(Date.parse(date.value))) {
        throw new Error(`Found invalid value for date: [${date.value}]`);
    }
    return new Date(date.value);
}
/**
 * Get the issuance date of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const date = getIssuanceDate(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The issuance date
 */
function getIssuanceDate(vc) {
    return wrapDate(getSingleObject(vc, namedNode(getId(vc)), cred.issuanceDate, "Literal"));
}
/**
 * Get the expiration date of a Verifiable Credential.
 *
 * @example
 *
 * ```
 * const date = getExpirationDate(vc);
 * ```
 *
 * @param vc The Verifiable Credential
 * @returns The expiration date, or undefined if none is found.
 */
function getExpirationDate(vc) {
    const res = [
        ...vc.match(namedNode(getId(vc)), cred.expirationDate, undefined, defaultGraph()),
    ];
    if (res.length === 0)
        return undefined;
    if (res.length !== 1)
        throw new Error(`Expected 0 or 1 expiration date. Found ${res.length}.`);
    if (res[0].object.termType !== "Literal")
        throw new Error(`Expected expiration date to be a Literal. Found [${res[0].object.value}] of type [${res[0].object.termType}].`);
    return wrapDate(res[0].object);
}
/**
 * @internal
 */
function isDate(literal) {
    return (!!literal &&
        literal.datatype.equals(xsd.dateTime) &&
        !Number.isNaN(Date.parse(literal.value)));
}
function isValidProof(dataset, proof) {
    return (isDate(lenientSingle(dataset.match(null, dc.created, null, proof), [
        "Literal",
    ])) &&
        lenientSingle(dataset.match(null, sec.proofValue, null, proof), [
            "Literal",
        ]) !== undefined &&
        lenientSingle(dataset.match(null, sec.proofPurpose, null, proof), ["NamedNode"]) !== undefined &&
        lenientSingle(dataset.match(null, sec.verificationMethod, null, proof), ["NamedNode"]) !== undefined &&
        lenientSingle(dataset.match(null, rdf.type, null, proof), [
            "NamedNode",
        ]) !== undefined);
}

export { getCredentialSubject, getExpirationDate, getId, getIssuanceDate, getIssuer, isDate, isValidProof };
