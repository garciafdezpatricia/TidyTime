import { acp_ess_2 } from '@inrupt/solid-client';
import { gc, solidVc } from '../../common/constants.mjs';
import { getSessionFetch } from '../../common/util/getSessionFetch.mjs';
import { ACL_RESOURCE_ACCESS_MODE_APPEND, ACL_RESOURCE_ACCESS_MODE_READ, ACL_RESOURCE_ACCESS_MODE_WRITE } from '../../type/ResourceAccessMode.mjs';
import { isAccessGrant } from '../guard/isAccessGrant.mjs';
import { isBaseAccessGrantVerifiableCredential, isRdfjsBaseAccessGrantVerifiableCredential } from '../guard/isBaseAccessGrantVerifiableCredential.mjs';
import { getBaseAccess } from '../util/getBaseAccessVerifiableCredential.mjs';
import { initializeGrantParameters } from '../util/initializeGrantParameters.mjs';
import { getGrantBody, issueAccessVc } from '../util/issueAccessVc.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// eslint-disable-next-line camelcase
/**
 * Internal function. This is a stopgap until we have proper JSON-LD parsing.
 * It enforces the shape of the JSON returned by the issuer service, which may
 * vary while still serializing the same data.
 *
 * In particular, this transforms some literals into a one-value array.
 *
 * @hidden
 * @param accessGrant The grant returned by the VC issuer
 * @returns An equivalent JSON-LD document framed according to our typing.
 */
function normalizeAccessGrant(accessGrant) {
    // Proper type checking is performed after normalization, so casting here is fine.
    const normalized = { ...accessGrant };
    if (normalized.credentialSubject.providedConsent === undefined) {
        throw new Error(`[${normalized.id}] is not an Access Grant: missing field "credentialSubject.providedConsent".`);
    }
    if (!Array.isArray(normalized.credentialSubject.providedConsent.mode)) {
        normalized.credentialSubject.providedConsent.mode = [
            normalized.credentialSubject.providedConsent.mode,
        ];
    }
    if (!Array.isArray(normalized.credentialSubject.providedConsent.forPersonalData)) {
        normalized.credentialSubject.providedConsent.forPersonalData = [
            normalized.credentialSubject.providedConsent.forPersonalData,
        ];
    }
    if (typeof normalized.credentialSubject.providedConsent.inherit === "string") {
        // Literals are also interpreted based on the JSON-LD context, so a "true" value
        // could map to a "true"^^xsd:boolean, which is a boolean.
        normalized.credentialSubject.providedConsent.inherit =
            normalized.credentialSubject.providedConsent.inherit === "true";
    }
    // Cast back to the original type
    return normalized;
}
function getAccessModesFromAccessGrant(request) {
    const accessMode = {};
    const requestModes = request.credentialSubject.providedConsent.mode;
    accessMode.append = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_APPEND);
    accessMode.read = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_READ);
    accessMode.write = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_WRITE);
    return accessMode;
}
async function addVcMatcher(targetResources, accessMode, options) {
    return Promise.all(targetResources.map(async (targetResource) => {
        var _a;
        // eslint-disable-next-line camelcase
        const resourceInfo = await acp_ess_2.getResourceInfoWithAcr(targetResource, options);
        // eslint-disable-next-line camelcase
        if (!acp_ess_2.hasAccessibleAcr(resourceInfo)) {
            throw new Error("The current user does not have access to the resource's Access Control Resource. Either they have insufficiant credentials, or the resource is not controlled using ACP. In either case, an Access Grant cannot be issued.");
        }
        // eslint-disable-next-line camelcase
        const updatedResource = acp_ess_2.setVcAccess(resourceInfo, accessMode, {
            inherit: (_a = options === null || options === void 0 ? void 0 : options.inherit) !== null && _a !== void 0 ? _a : true,
        });
        // eslint-disable-next-line camelcase
        return acp_ess_2.saveAcrFor(updatedResource, options);
    }));
}
async function approveAccessRequest(requestVc, requestOverride, options = {}) {
    var _a, _b, _c;
    const internalOptions = {
        ...options,
        fetch: (_a = options.fetch) !== null && _a !== void 0 ? _a : (await getSessionFetch(options)),
        updateAcr: (_b = options.updateAcr) !== null && _b !== void 0 ? _b : true,
    };
    const internalGrantOptions = initializeGrantParameters(typeof requestVc !== "undefined"
        ? await getBaseAccess(requestVc, options, solidVc.SolidAccessRequest, gc.ConsentStatusRequested)
        : undefined, requestOverride);
    const grantBody = getGrantBody({
        access: internalGrantOptions.access,
        requestor: internalGrantOptions.requestor,
        resources: internalGrantOptions.resources,
        requestorInboxUrl: internalGrantOptions.requestorInboxUrl,
        purpose: internalGrantOptions.purpose,
        issuanceDate: internalGrantOptions.issuanceDate,
        expirationDate: (_c = internalGrantOptions.expirationDate) !== null && _c !== void 0 ? _c : undefined,
        status: gc.ConsentStatusExplicitlyGiven.value,
        inherit: internalGrantOptions.inherit,
    });
    const grantedAccess = getAccessModesFromAccessGrant(grantBody);
    if (internalOptions.updateAcr === true) {
        await addVcMatcher(grantBody.credentialSubject.providedConsent.forPersonalData, grantedAccess, internalOptions);
    }
    const accessGrant = await issueAccessVc(grantBody, {
        ...internalOptions,
        returnLegacyJsonld: options.returnLegacyJsonld,
        normalize: normalizeAccessGrant,
    });
    if (options.returnLegacyJsonld !== false
        ? !isBaseAccessGrantVerifiableCredential(accessGrant) ||
            !isAccessGrant(accessGrant)
        : !isRdfjsBaseAccessGrantVerifiableCredential(accessGrant)) {
        throw new Error(`Unexpected response when approving Access Request, the result is not an Access Grant: ${JSON.stringify(accessGrant)}`);
    }
    return accessGrant;
}

export { approveAccessRequest, approveAccessRequest as default, normalizeAccessGrant };
