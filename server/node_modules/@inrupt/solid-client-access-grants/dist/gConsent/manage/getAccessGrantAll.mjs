import { getVerifiableCredentialAllFromShape } from '@inrupt/solid-client-vc';
import { CONTEXT_VC_W3C, CONTEXT_ESS_DEFAULT, CREDENTIAL_TYPE_BASE, CREDENTIAL_TYPE_ACCESS_GRANT, CREDENTIAL_TYPE_ACCESS_DENIAL } from '../constants.mjs';
import { getAccessApiEndpoint } from '../discover/getAccessApiEndpoint.mjs';
import { accessToResourceAccessModeArray } from '../util/accessToResourceAccessModeArray.mjs';
import { getSessionFetch } from '../../common/util/getSessionFetch.mjs';
import { isAccessGrant } from '../guard/isAccessGrant.mjs';
import { isRdfjsBaseAccessGrantVerifiableCredential, isBaseAccessGrantVerifiableCredential } from '../guard/isBaseAccessGrantVerifiableCredential.mjs';
import { getInherit, getResources } from '../../common/getters.mjs';
import { normalizeAccessGrant } from './approveAccessRequest.mjs';
import { gc } from '../../common/constants.mjs';

//
// Copyright Inrupt Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
// Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// Iteratively build the list of ancestor containers from the breakdown of the
// resource path: for resource https://pod.example/foo/bar/baz, we'll want the result
// to be ["https://pod.example/", "https://pod.example/foo/", "https://pod.example/foo/bar/", https://pod.example/foo/bar/baz].
const getAncestorUrls = (resourceUrl) => {
    // Splitting on / will result in the first element being empty (since the path
    // starts with /) and in the last element being the target resource name.
    const ancestorNames = resourceUrl.pathname
        .split("/")
        .slice(1, resourceUrl.pathname.endsWith("/") ? -2 : -1);
    return ancestorNames.reduce((ancestors, curName) => {
        // Add each intermediary container to ancestorPaths
        const currentPath = `${ancestors[0]}${curName}/`;
        return [new URL(currentPath, resourceUrl.origin), ...ancestors];
    }, 
    // The storage origin may be the storage root (it happens not to be the case in ESS).
    // The target resource should also be included.
    [new URL("/", resourceUrl.origin), resourceUrl]);
};
async function getAccessGrantAll(params, options = {}) {
    var _a, _b;
    if (!params.resource && !options.accessEndpoint) {
        throw new Error("resource and accessEndpoint cannot both be undefined");
    }
    const sessionFetch = await getSessionFetch(options);
    // TODO: Fix access API endpoint retrieval (should include all the different API endpoints)
    const queryEndpoint = options.accessEndpoint
        ? new URL("derive", options.accessEndpoint)
        : new URL("derive", await getAccessApiEndpoint(params.resource, options));
    const ancestorUrls = params.resource
        ? getAncestorUrls(typeof params.resource === "string"
            ? new URL(params.resource)
            : params.resource)
        : [undefined];
    const specifiedModes = accessToResourceAccessModeArray((_a = params.access) !== null && _a !== void 0 ? _a : {});
    const type = [CREDENTIAL_TYPE_BASE];
    const statusShorthand = (_b = params.status) !== null && _b !== void 0 ? _b : "granted";
    if (statusShorthand === "granted") {
        type.push(CREDENTIAL_TYPE_ACCESS_GRANT);
    }
    else if (statusShorthand === "denied") {
        type.push(CREDENTIAL_TYPE_ACCESS_DENIAL);
    }
    const vcShapes = ancestorUrls.map((url) => ({
        "@context": [CONTEXT_VC_W3C, CONTEXT_ESS_DEFAULT],
        type,
        credentialSubject: {
            providedConsent: {
                hasStatus: {
                    granted: gc.ConsentStatusExplicitlyGiven.value,
                    denied: gc.ConsentStatusDenied.value,
                    all: undefined,
                }[statusShorthand],
                forPersonalData: url ? [url.href] : undefined,
                forPurpose: params.purpose,
                isProvidedTo: params.requestor,
                mode: specifiedModes.length > 0 ? specifiedModes : undefined,
            },
        },
    }));
    let result;
    if (options.returnLegacyJsonld === false) {
        // TODO: Fix up the type of accepted arguments (this function should allow deep partial)
        result = (await Promise.all(vcShapes.map((vcShape) => getVerifiableCredentialAllFromShape(queryEndpoint.href, vcShape, {
            fetch: sessionFetch,
            includeExpiredVc: options.includeExpired,
            returnLegacyJsonld: false,
        }))))
            // getVerifiableCredentialAllFromShape returns a list, so the previous map
            // should be flattened to have all the candidate grants in a non-nested list.
            .flat()
            .filter((vc) => isRdfjsBaseAccessGrantVerifiableCredential(vc));
    }
    else {
        result = (await Promise.all(vcShapes.map((vcShape) => getVerifiableCredentialAllFromShape(queryEndpoint.href, vcShape, {
            fetch: sessionFetch,
            includeExpiredVc: options.includeExpired,
            normalize: normalizeAccessGrant,
        }))))
            // getVerifiableCredentialAllFromShape returns a list, so the previous map
            // should be flattened to have all the candidate grants in a non-nested list.
            .flat()
            .filter((vc) => isBaseAccessGrantVerifiableCredential(vc) && isAccessGrant(vc));
    }
    // Explicitly non-recursive grants are filtered out, except if they apply
    // directly to the target resource (in the case a resource is used as a
    // filtering criteria for getAccessGrantAll).
    return result.filter((vc) => getInherit(vc) !== false ||
        params.resource === undefined ||
        getResources(vc).includes(params.resource.toString()));
}

export { getAccessGrantAll as default, getAccessGrantAll };
