(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('n3'), require('rdf-namespaces'), require('@inrupt/solid-client-vc'), require('auth-header'), require('@inrupt/solid-client'), require('base64url')) :
  typeof define === 'function' && define.amd ? define(['exports', 'n3', 'rdf-namespaces', '@inrupt/solid-client-vc', 'auth-header', '@inrupt/solid-client', 'base64url'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SolidAccess = {}, global.n3, global.rdfNamespaces, global.solidClientVc, global.authHeader, global.solidClient, global.base64url));
})(this, (function (exports, n3, rdfNamespaces, solidClientVc, authHeader, solidClient, base64url) { 'use strict';

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { namedNode: namedNode$4 } = n3.DataFactory;
  const GC = "https://w3id.org/GConsent#";
  const VC = "http://www.w3.org/ns/solid/vc#";
  const XSD = "http://www.w3.org/2001/XMLSchema#";
  const XSD_BOOLEAN = namedNode$4(`${XSD}boolean`);
  const TYPE = namedNode$4(rdfNamespaces.rdf.type);
  const solidVc = {
      SolidAccessRequest: namedNode$4(`${VC}SolidAccessRequest`),
      SolidAccessGrant: namedNode$4(`${VC}SolidAccessGrant`),
      SolidAccessDenial: namedNode$4(`${VC}SolidAccessDenial`),
  };
  const gc = {
      providedConsent: namedNode$4(`${GC}providedConsent`),
      hasConsent: namedNode$4(`${GC}hasConsent`),
      hasStatus: namedNode$4(`${GC}hasStatus`),
      isProvidedTo: namedNode$4(`${GC}isProvidedTo`),
      isConsentForDataSubject: namedNode$4(`${GC}isConsentForDataSubject`),
      forPurpose: namedNode$4(`${GC}forPurpose`),
      forPersonalData: namedNode$4(`${GC}forPersonalData`),
      ConsentStatusDenied: namedNode$4(`${GC}ConsentStatusDenied`),
      ConsentStatusExplicitlyGiven: namedNode$4(`${GC}ConsentStatusExplicitlyGiven`),
      ConsentStatusRequested: namedNode$4(`${GC}ConsentStatusRequested`),
  };
  const acl = {
      Read: namedNode$4(rdfNamespaces.acl.Read),
      Write: namedNode$4(rdfNamespaces.acl.Write),
      Append: namedNode$4(rdfNamespaces.acl.Append),
      mode: namedNode$4(rdfNamespaces.acl.mode),
  };
  const ldp = {
      inbox: namedNode$4("http://www.w3.org/ns/ldp#inbox"),
  };
  const INHERIT = namedNode$4("urn:uuid:71ab2f68-a68b-4452-b968-dd23e0570227");

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const GC_CONSENT_STATUS_DENIED_ABBREV = "ConsentStatusDenied";
  const GC_CONSENT_STATUS_EXPLICITLY_GIVEN_ABBREV = "ConsentStatusExplicitlyGiven";
  const GC_CONSENT_STATUS_REQUESTED_ABBREV = "ConsentStatusRequested";
  // TODO: Add dependency on generated vocabulary.
  const PIM_STORAGE = "http://www.w3.org/ns/pim/space#storage";
  // TODO: This is a temporary filler term, until we publish a definitive term for this.
  const PREFERRED_CONSENT_MANAGEMENT_UI = "http://inrupt.com/ns/ess#ConsentManagementUI";
  const CONTEXT_VC_W3C = "https://www.w3.org/2018/credentials/v1";
  // This static context is used from the 2.1 version, instead of having a context
  // specific to the deployment.
  const CONTEXT_ESS_DEFAULT = "https://schema.inrupt.com/credentials/v1.jsonld";
  // According to the [ESS documentation](https://docs.inrupt.com/ess/latest/services/service-vc/#ess-vc-service-endpoints),
  // the JSON-LD context for ESS-issued VCs will match the following template.
  const instanciateContextVcEssTemplate = (essVcDomain) => `https://${essVcDomain}/credentials/v1`;
  const extraContext = [
      "https://w3id.org/security/data-integrity/v1",
      "https://w3id.org/vc-revocation-list-2020/v1",
      "https://w3id.org/vc/status-list/2021/v1",
      "https://w3id.org/security/suites/ed25519-2020/v1",
  ];
  // A default context value is provided for mocking purpose accross the codebase.
  const ACCESS_GRANT_CONTEXT_DEFAULT = [
      CONTEXT_VC_W3C,
      CONTEXT_ESS_DEFAULT,
      instanciateContextVcEssTemplate("vc.inrupt.com"),
  ];
  [
      ...ACCESS_GRANT_CONTEXT_DEFAULT,
      ...extraContext,
  ];
  // When issuing a VC using a given service,"https://schema.inrupt.com/credentials/v1.jsonld" be sure to set the context using the following.
  const instanciateEssAccessGrantContext = (essVcDomain) => [
      CONTEXT_VC_W3C,
      CONTEXT_ESS_DEFAULT,
      instanciateContextVcEssTemplate(essVcDomain),
  ];
  const CREDENTIAL_TYPE_ACCESS_REQUEST = "SolidAccessRequest";
  const CREDENTIAL_TYPE_ACCESS_GRANT = "SolidAccessGrant";
  const CREDENTIAL_TYPE_ACCESS_DENIAL = "SolidAccessDenial";
  const CREDENTIAL_TYPE_BASE = "VerifiableCredential";
  const PRESENTATION_TYPE_BASE = "VerifiablePresentation";
  const ACCESS_CREDENTIAL_TYPE = new Set([
      CREDENTIAL_TYPE_ACCESS_REQUEST,
      CREDENTIAL_TYPE_ACCESS_GRANT,
      CREDENTIAL_TYPE_ACCESS_DENIAL,
      "vc:SolidAccessDenial",
  ]);
  const ACCESS_GRANT_STATUS = Object.freeze(new Set([
      gc.ConsentStatusDenied.value,
      gc.ConsentStatusExplicitlyGiven.value,
      GC_CONSENT_STATUS_DENIED_ABBREV,
      "gc:ConsentStatusDenied",
      "Consent:StatusDenied",
      GC_CONSENT_STATUS_EXPLICITLY_GIVEN_ABBREV,
  ]));
  const ACCESS_REQUEST_STATUS = Object.freeze(new Set([
      gc.ConsentStatusRequested.value,
      GC_CONSENT_STATUS_REQUESTED_ABBREV,
  ]));
  const ACCESS_STATUS = Object.freeze(new Set([...ACCESS_GRANT_STATUS, ...ACCESS_REQUEST_STATUS]));

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // Implemented as isGConsentAccessGrant in src/common/getters as isGConsentAccessGrant
  function isAccessGrant(vc) {
      return (vc.credentialSubject.providedConsent !== undefined &&
          ACCESS_GRANT_STATUS.has(vc.credentialSubject.providedConsent.hasStatus) &&
          typeof vc.credentialSubject.providedConsent
              .isProvidedTo === "string");
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Grant,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  const CredentialIsAccessGrantGConsent = isAccessGrant;

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated
   */
  function isAccessCredentialType(x) {
      return Array.isArray(x) && x.some((y) => ACCESS_CREDENTIAL_TYPE.has(y));
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated
   */
  function isAccessGrantContext(x) {
      return Array.isArray(x) && x.includes(CONTEXT_VC_W3C);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isUnknownObject(x) {
      return x !== null && typeof x === "object";
  }

  const { namedNode: namedNode$3, defaultGraph: defaultGraph$3, quad: quad$5, literal: literal$1 } = n3.DataFactory;
  function getSingleObject(vc, subject, predicate, type, required = true) {
      const results = [...vc.match(subject, predicate, null, defaultGraph$3())];
      if (results.length === 0 && !required) {
          return undefined;
      }
      if (results.length !== 1) {
          throw new Error(`Expected exactly one result. Found ${results.length}.`);
      }
      const [{ object }] = results;
      const expectedTypes = type ? [type] : ["NamedNode", "BlankNode"];
      if (!expectedTypes.includes(object.termType)) {
          throw new Error(`Expected [${object.value}] to be a ${expectedTypes.join(" or ")}. Found [${object.termType}]`);
      }
      return object;
  }
  /**
   * @internal
   */
  function getConsent(vc) {
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      const consents = [
          ...vc.match(credentialSubject, gc.providedConsent, null, defaultGraph$3()),
          ...vc.match(credentialSubject, gc.hasConsent, null, defaultGraph$3()),
      ];
      if (consents.length !== 1) {
          throw new Error(`Expected exactly 1 consent value. Found ${consents.length}.`);
      }
      const [{ object }] = consents;
      if (object.termType !== "BlankNode" && object.termType !== "NamedNode") {
          throw new Error(`Expected consent to be a Named Node or Blank Node, instead got [${object.termType}].`);
      }
      return object;
  }
  /**
   * Get the resources to which an Access Grant/Request applies.
   *
   * @example
   *
   * ```
   * const resources = getResources(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The resources IRIs
   */
  function getResources(vc) {
      const resources = [];
      for (const { object } of vc.match(getConsent(vc), gc.forPersonalData, null, defaultGraph$3())) {
          if (object.termType !== "NamedNode") {
              throw new Error(`Expected resource to be a Named Node. Instead got [${object.value}] with term type [${object.termType}]`);
          }
          resources.push(object.value);
      }
      return resources;
  }
  /**
   * Get the purposes for which an Access Grant/Request applies.
   *
   * @example
   *
   * ```
   * const purposes = getPurposes(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The purpose IRIs
   */
  function getPurposes(vc) {
      const consent = getConsent(vc);
      const purposes = [];
      for (const { object } of vc.match(consent, gc.forPurpose, null, defaultGraph$3())) {
          if (object.termType !== "NamedNode") {
              throw new Error(`Expected purpose to be Named Node. Instead got [${object.value}] with term type [${object.termType}]`);
          }
          purposes.push(object.value);
      }
      return purposes;
  }
  function isGConsentAccessGrant(vc) {
      var _a;
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      const providedConsent = getSingleObject(vc, credentialSubject, gc.providedConsent, undefined, false);
      if (!providedConsent)
          return false;
      const gcStatus = getSingleObject(vc, providedConsent, gc.hasStatus, undefined, false);
      return (gcStatus !== undefined &&
          (vc.has(quad$5(providedConsent, gc.hasStatus, gc.ConsentStatusDenied)) ||
              vc.has(quad$5(providedConsent, gc.hasStatus, gc.ConsentStatusExplicitlyGiven))) &&
          ((_a = getSingleObject(vc, providedConsent, gc.isProvidedTo, undefined, false)) === null || _a === void 0 ? void 0 : _a.termType) === "NamedNode");
  }
  function getResourceOwner(vc) {
      var _a;
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      if (isGConsentAccessGrant(vc)) {
          return credentialSubject.value;
      }
      return (_a = getSingleObject(vc, getSingleObject(vc, credentialSubject, gc.hasConsent), gc.isConsentForDataSubject, "NamedNode", false)) === null || _a === void 0 ? void 0 : _a.value;
  }
  /**
   * Get the requestor asking for access to a resources with an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const requestorWebId = getRequestor(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The requestor WebID
   */
  function getRequestor(vc) {
      const credentialSubject = solidClientVc.getCredentialSubject(vc);
      const providedConsent = getSingleObject(vc, credentialSubject, gc.providedConsent, undefined, false);
      if (!providedConsent)
          return credentialSubject.value;
      return getSingleObject(vc, providedConsent, gc.isProvidedTo, "NamedNode")
          .value;
  }
  /**
   * Get the inbox of the requestor of an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const inbox = getInbox(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The requestors inbox
   */
  function getInbox(vc) {
      try {
          return getSingleObject(vc, solidClientVc.getCredentialSubject(vc), ldp.inbox, "NamedNode")
              .value;
      }
      catch (_a) {
          return undefined;
      }
  }
  /**
   * Get the access modes granted to a resources via an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const modes = getAccessModes(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The access modes the grant recipient can exercise.
   */
  function getAccessModes(vc) {
      const consent = getConsent(vc);
      return {
          read: vc.has(quad$5(consent, acl.mode, acl.Read, defaultGraph$3())),
          write: vc.has(quad$5(consent, acl.mode, acl.Write, defaultGraph$3())),
          append: vc.has(quad$5(consent, acl.mode, acl.Append, defaultGraph$3())),
      };
  }
  const shorthand = {
      "http://www.w3.org/ns/solid/vc#SolidAccessRequest": "SolidAccessRequest",
      "http://www.w3.org/ns/solid/vc#SolidAccessDenial": "SolidAccessDenial",
      "http://www.w3.org/ns/solid/vc#SolidAccessGrant": "SolidAccessGrant",
      "https://www.w3.org/2018/credentials#VerifiableCredential": "VerifiableCredential",
      "https://www.w3.org/2018/credentials#VerifiablePresentation": "VerifiablePresentation",
  };
  /**
   * Get the VC types of an Access Grant/Request.
   *
   * @example
   *
   * ```
   * const types = getTypes(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns The VC types
   */
  function getTypes(vc) {
      const results = [
          ...vc.match(namedNode$3(solidClientVc.getId(vc)), TYPE, undefined, defaultGraph$3()),
      ].map((res) => res.object);
      const types = [];
      for (const result of results) {
          if (result.termType !== "NamedNode") {
              throw new Error(`Expected every type to be a Named Node, but found [${result.value}] with term type [${result.termType}]`);
          }
          types.push(result.value);
          if (result.value in shorthand) {
              types.push(shorthand[result.value]);
          }
      }
      return types;
  }
  /**
   * Check whether a given Access Grant applies recursively to child resources or not.
   *
   * @example
   *
   * ```
   * const isInherited = getInherit(accessGrant);
   * ```
   *
   * @param vc The Access Grant/Request
   * @returns true if the Grant applies to contained resources, false otherwise.
   */
  function getInherit$1(vc) {
      return !vc.has(quad$5(getConsent(vc), INHERIT, literal$1("false", XSD_BOOLEAN), defaultGraph$3()));
  }
  /**
   * This class wraps all the accessor functions on a raw Access Grant JSON object.
   * It wraps all the supported Access Grants data models, namely GConsent.
   *
   * @example
   *
   * ```
   * const rawGrant = await getAccessGrantFromRedirectUrl(someUrl, { fetch: session.fetch });
   * const grant = new AccessGrant(grant);
   * const grantOwner = grant.getResourceOwner();
   * ```
   */
  class AccessGrantWrapper {
      constructor(vc) {
          this.vc = vc;
      }
      getPurposes() {
          return getPurposes(this.vc);
      }
      getInbox() {
          return getInbox(this.vc);
      }
      getResources() {
          return getResources(this.vc);
      }
      getResourceOwner() {
          return getResourceOwner(this.vc);
      }
      getRequestor() {
          return getRequestor(this.vc);
      }
      getAccessModes() {
          return getAccessModes(this.vc);
      }
      getId() {
          return solidClientVc.getId(this.vc);
      }
      getTypes() {
          return getTypes(this.vc);
      }
      getIssuanceDate() {
          return solidClientVc.getIssuanceDate(this.vc);
      }
      getExpirationDate() {
          return solidClientVc.getExpirationDate(this.vc);
      }
      getIssuer() {
          return solidClientVc.getIssuer(this.vc);
      }
      getInherit() {
          return getInherit$1(this.vc);
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const ACL_RESOURCE_ACCESS_MODE_APPEND = "http://www.w3.org/ns/auth/acl#Append";
  const ACL_RESOURCE_ACCESS_MODE_READ = "http://www.w3.org/ns/auth/acl#Read";
  const ACL_RESOURCE_ACCESS_MODE_WRITE = "http://www.w3.org/ns/auth/acl#Write";
  const ACL_RESOURCE_ACCESS_MODE_APPEND_ABBREV = "Append";
  const ACL_RESOURCE_ACCESS_MODE_READ_ABBREV = "Read";
  const ACL_RESOURCE_ACCESS_MODE_WRITE_ABBREV = "Write";
  const RESOURCE_ACCESS_MODE = new Set([
      ACL_RESOURCE_ACCESS_MODE_APPEND,
      ACL_RESOURCE_ACCESS_MODE_READ,
      ACL_RESOURCE_ACCESS_MODE_WRITE,
      // The following are linked to the previous through our JSON-LD context.
      ACL_RESOURCE_ACCESS_MODE_READ_ABBREV,
      ACL_RESOURCE_ACCESS_MODE_WRITE_ABBREV,
      ACL_RESOURCE_ACCESS_MODE_APPEND_ABBREV,
  ]);

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { defaultGraph: defaultGraph$2 } = n3.DataFactory;
  function isResourceAccessModeArray(x) {
      return Array.isArray(x) && x.every((y) => RESOURCE_ACCESS_MODE.has(y));
  }
  function isGConsentStatus(x) {
      return typeof x === "string" && ACCESS_STATUS.has(x);
  }
  // TODO: Discuss a strongly typed UrlString guard (as a team).
  function isStringArray(x) {
      return Array.isArray(x) && x.every((y) => typeof y === "string");
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isGConsentAttributes(x) {
      return (isUnknownObject(x) &&
          isResourceAccessModeArray(x.mode) &&
          isGConsentStatus(x.hasStatus) &&
          isStringArray(x.forPersonalData));
  }
  function isRdfjsGConsentAttributes(dataset, 
  // eslint-disable-next-line camelcase
  consent) {
      // isResourceAccessModeArray
      const modeQuads = dataset.match(consent, acl.mode, null, defaultGraph$2());
      if (modeQuads.size === 0) {
          return false;
      }
      for (const { object: mode } of modeQuads) {
          if (![acl.Append, acl.Read, acl.Write].some((allowedMode) => allowedMode.equals(mode))) {
              return false;
          }
      }
      // isGConsentStatus
      const statuses = [
          ...dataset.match(consent, gc.hasStatus, null, defaultGraph$2()),
      ];
      if (statuses.length !== 1 ||
          ![
              gc.ConsentStatusDenied,
              gc.ConsentStatusExplicitlyGiven,
              gc.ConsentStatusRequested,
          ].some((e) => e.equals(statuses[0].object))) {
          return false;
      }
      const forPersonalData = dataset.match(consent, gc.forPersonalData, null, defaultGraph$2());
      if (forPersonalData.size === 0) {
          throw new Error("No Personal Data specified for Access Grant");
      }
      for (const { object } of forPersonalData) {
          if (object.termType !== "NamedNode") {
              return false;
          }
      }
      return true;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { namedNode: namedNode$2, quad: quad$4 } = n3.DataFactory;
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseAccessVcBody(x) {
      return (isUnknownObject(x) &&
          isAccessGrantContext(x["@context"]) &&
          Array.isArray(x.type) &&
          isAccessCredentialType(x.type) &&
          isUnknownObject(x.credentialSubject) &&
          typeof x.credentialSubject.id === "string" &&
          (typeof x.credentialSubject.inbox === "string" ||
              typeof x.credentialSubject.inbox === "undefined") &&
          (x.issuanceDate !== undefined ? typeof x.issuanceDate === "string" : true));
  }
  function isRdfjsAccessVerifiableCredential(data, expectedTypes) {
      const s = namedNode$2(solidClientVc.getId(data));
      if (!expectedTypes.some((type) => data.has(quad$4(s, TYPE, type)))) {
          return false;
      }
      // getConsent and getIssuanceDate can error
      try {
          solidClientVc.getIssuanceDate(data);
          return isRdfjsGConsentAttributes(data, getConsent(data));
      }
      catch (e) {
          return false;
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated Use RDFJS API instead.
   */
  function CredentialIsAccessGrantAny(vc) {
      return isBaseAccessVcBody(vc) && CredentialIsAccessGrantGConsent(vc);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function getAccessEndpointForResource(resource) {
      // Explicitly makes an unauthenticated fetch to be sure to get the link to the
      // authorization server.
      const response = await fetch(resource);
      if (!response.headers.has("WWW-Authenticate")) {
          throw new Error(`Expected a 401 error with a WWW-Authenticate header, got a [${response.status}: ${response.statusText}] response lacking the WWW-Authenticate header.`);
      }
      const authHeader$1 = response.headers.get("WWW-Authenticate");
      const authHeaderToken = authHeader.parse(authHeader$1);
      if (authHeaderToken.scheme !== "UMA") {
          throw new Error(`Unsupported authorization scheme: [${authHeaderToken.scheme}]`);
      }
      const authorizationServerIri = authHeaderToken.params.as_uri;
      const wellKnownIri = new URL("/.well-known/uma2-configuration", authorizationServerIri);
      const rawDiscoveryDocument = await fetch(wellKnownIri.href);
      const discoveryDocument = await rawDiscoveryDocument.json();
      if (typeof discoveryDocument.verifiable_credential_issuer !== "string") {
          throw new Error(`No access issuer listed for property [verifiable_credential_issuer] in [${JSON.stringify(discoveryDocument)}]`);
      }
      return discoveryDocument.verifiable_credential_issuer;
  }
  /**
   * Discovers the endpoint where access requests may be created for a given resource.
   *
   * @param resource The resource for which access may be requested.
   * @param options Optional properties to customise the access request behaviour.
   * @returns The URL of the access request server.
   * @since 0.4.0
   */
  async function getAccessApiEndpoint(resource, options = {}) {
      if (options.accessEndpoint !== undefined) {
          return options.accessEndpoint.toString();
      }
      return getAccessEndpointForResource(resource.toString());
  }

  /**
   * Dynamically import solid-client-authn-browser so that
   * this library doesn't have a hard dependency.
   *
   * @returns fetch function
   */
  async function getSessionFetch(options) {
      if (options.fetch) {
          return options.fetch;
      }
      try {
          const { fetch: fetchFn } = await import(
          // @inrupt/solid-client-authn-browser is not in this code's direct dependencies,
          // we dynamically check whether it is in the caller's dependencies.
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          // eslint-disable-next-line import/no-unresolved
          '@inrupt/solid-client-authn-browser');
          return fetchFn;
      }
      catch (e) {
          /* istanbul ignore next: @inrupt/solid-client-authn-browser is a devDependency, so this path is not hit in tests: */
          return fetch;
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function getAccessManagementUiFromProfile(webId, options) {
      const result = {};
      let webIdDocument;
      try {
          webIdDocument = await solidClient.getSolidDataset(webId, {
              fetch: options.fetch,
          });
      }
      catch (e) {
          throw new Error(`Cannot get the Access Management UI for ${webId}: ${e}.`);
      }
      const profile = solidClient.getThing(webIdDocument, webId);
      if (profile === null) {
          throw new Error(`Cannot get the Access Management UI for ${webId}: the WebID cannot be dereferenced.`);
      }
      // TODO: rename constant & variable when a definitive term is published:
      const profileConsentUi = solidClient.getIri(profile, PREFERRED_CONSENT_MANAGEMENT_UI);
      if (profileConsentUi !== null) {
          result.accessEndpoint = profileConsentUi;
      }
      // If the profile document does not advertize for the access management UI, look for a storage root.
      const storage = solidClient.getIri(profile, PIM_STORAGE);
      if (storage !== null) {
          result.storage = storage;
      }
      return result;
  }
  /**
   * @since 0.4.0
   * @hidden
   */
  async function getAccessManagementUiFromWellKnown(storage, options) {
      if (storage === undefined) {
          return undefined;
      }
      const wellKnown = await solidClient.getWellKnownSolid(storage, {
          fetch: options.fetch,
      });
      if (solidClient.getThingAll(wellKnown, { acceptBlankNodes: true }).length === 0) {
          return undefined;
      }
      const wellKnownAccesstUi = solidClient.getIri(solidClient.getThingAll(wellKnown, { acceptBlankNodes: true })[0], PREFERRED_CONSENT_MANAGEMENT_UI);
      return wellKnownAccesstUi !== null && wellKnownAccesstUi !== void 0 ? wellKnownAccesstUi : undefined;
  }
  /**
   * Get the endpoint where the user prefers to be redirected when asked for access.
   * If the user does not specify an endpoint, this function attempts to discover the
   * default access UI recommended by their Pod provider.
   *
   * @param webId The WebID of the user asked for access.
   * @param options Optional properties to customise the access request behaviour.
   * @returns The URL where the user should be redirected, if discoverable.
   * @since 0.4.0
   */
  async function getAccessManagementUi(webId, options = {}) {
      const fetcher = await getSessionFetch(options);
      // TODO: Complete code coverage for URL argument
      const { accessEndpoint, storage } = await getAccessManagementUiFromProfile(webId.toString(), { fetch: fetcher });
      return (accessEndpoint !== null && accessEndpoint !== void 0 ? accessEndpoint : getAccessManagementUiFromWellKnown(storage, { fetch: fetcher }));
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad: quad$3, namedNode: namedNode$1 } = n3.DataFactory;
  async function getBaseAccess(vc, options, type, hasStatus) {
      let baseVc;
      if (typeof vc === "string" || vc instanceof URL) {
          baseVc = await solidClientVc.getVerifiableCredential(vc.toString(), {
              returnLegacyJsonld: false,
              skipValidation: true,
              fetch: options.fetch,
          });
      }
      else {
          baseVc = vc;
      }
      if (type && !baseVc.has(quad$3(namedNode$1(solidClientVc.getId(baseVc)), TYPE, type))) {
          throw new Error(`An error occurred when type checking the VC: Not of type [${type.value}].`);
      }
      if (hasStatus &&
          !baseVc.has(quad$3(getConsent(baseVc), gc.hasStatus, hasStatus))) {
          throw new Error(`An error occurred when type checking the VC: status not [${hasStatus.value}].`);
      }
      return baseVc;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Internal function implementing redirection with some query parameters.
   *
   * @hidden
   */
  async function redirectWithParameters(target, queryParams, options) {
      const targetUrl = new URL(target);
      Object.entries(queryParams).forEach(([key, value]) => {
          targetUrl.searchParams.append(key, value);
      });
      if (options.redirectCallback !== undefined) {
          options.redirectCallback(targetUrl.href);
      }
      else {
          if (typeof window === "undefined") {
              throw new Error("In a non-browser environment, a redirectCallback must be provided by the user.");
          }
          window.location.href = targetUrl.href;
      }
      // This redirects the user away from the app, so unless it throws an error,
      // there is no code that should run afterwards (since there is no "after" in
      // script's lifetime). Hence, this Promise never resolves:
      return new Promise(() => { });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Makes a request to the access server to verify the validity of a given Verifiable Credential.
   *
   * @param vc Either a VC, or a URL to a VC, to be verified.
   * @param options Optional properties to customise the request behaviour.
   * @returns An object containing checks, warnings, and errors.
   * @since 0.4.0
   */
  // TODO: Push verification further as this just checks it's a valid VC should we not type check the consent grant?
  async function isValidAccessGrant(vc, options = {}) {
      var _a;
      const fetcher = await getSessionFetch(options);
      const vcObject = await getBaseAccess(vc, options);
      // Discover the access endpoint from the resource part of the Access Grant.
      const verifierEndpoint = (_a = options.verificationEndpoint) !== null && _a !== void 0 ? _a : (await solidClientVc.getVerifiableCredentialApiConfiguration(solidClientVc.getIssuer(vcObject)))
          .verifierService;
      if (verifierEndpoint === undefined) {
          throw new Error(`The VC service provider ${solidClientVc.getIssuer(vcObject)} does not advertize for a verifier service in its .well-known/vc-configuration document`);
      }
      const response = await fetcher(verifierEndpoint, {
          headers: {
              "Content-Type": "application/json",
          },
          method: "POST",
          body: JSON.stringify({
              verifiableCredential: vcObject,
          }),
      });
      // TODO: Add verifcation on the structure of the response
      return response.json();
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // This file is used to create a 'common' API object from the top-level exports.

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AccessGrantWrapper: AccessGrantWrapper,
    getAccessModes: getAccessModes,
    getExpirationDate: solidClientVc.getExpirationDate,
    getId: solidClientVc.getId,
    getIssuanceDate: solidClientVc.getIssuanceDate,
    getIssuer: solidClientVc.getIssuer,
    getRequestor: getRequestor,
    getResourceOwner: getResourceOwner,
    getResources: getResources,
    getTypes: getTypes,
    isValidAccessGrant: isValidAccessGrant
  });

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const REQUEST_VC_URL_PARAM_NAME = "requestVcUrl";
  const REDIRECT_URL_PARAM_NAME = "redirectUrl";
  async function discoverAccessManagementUi(options) {
      const authFetch = await getSessionFetch({ fetch: options.fetch });
      let accessManagementUi;
      if (options.resourceOwner) {
          accessManagementUi = await getAccessManagementUi(options.resourceOwner, {
              fetch: authFetch,
          });
      }
      else {
          accessManagementUi = await getAccessManagementUiFromWellKnown(options.resourceUrl, { fetch: authFetch });
      }
      return accessManagementUi !== null && accessManagementUi !== void 0 ? accessManagementUi : options.fallbackUi;
  }
  /**
   * Redirects the application to a resource owner's preferred access management
   * UI.
   *
   * @param accessRequestVc The VC containing the Access Request to a resource.
   * @param redirectUrl The URL where the user should be redirected back after
   * having granted access.
   * @param options If you are in a NodeJS environment, you must specify a
   * callback to handle the redirection.
   * @since 0.4.0
   */
  async function redirectToAccessManagementUi(accessRequestVc, redirectUrl, options = {}) {
      const fallbackUi = options.fallbackAccessManagementUi;
      const requestVc = await getBaseAccess(accessRequestVc, {
          fetch: options.fetch,
      });
      const [resourceUrl] = getResources(requestVc);
      const accessManagementUi = await discoverAccessManagementUi({
          resourceUrl,
          resourceOwner: options.resourceOwner,
          fallbackUi,
          fetch: options.fetch,
      });
      if (accessManagementUi === undefined) {
          throw new Error(`Cannot discover access management UI URL for [${resourceUrl}]${options.resourceOwner ? `, neither from [${options.resourceOwner}]` : ""}`);
      }
      return redirectWithParameters(accessManagementUi, {
          [`${REQUEST_VC_URL_PARAM_NAME}`]: encodeURI(requestVc.id),
          [`${REDIRECT_URL_PARAM_NAME}`]: encodeURI(typeof redirectUrl === "string" ? redirectUrl : redirectUrl.href),
      }, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad: quad$2, namedNode } = n3.DataFactory;
  /**
   * Makes a request to the access server to revoke a given Verifiable Credential (VC).
   *
   * @param vc Either a VC, or a URL to a VC, to be revoked.
   * @param options Optional properties to customise the request behaviour.
   * @returns A void promise.
   * @since 0.4.0
   */
  async function revokeAccessGrant(vc, options = {}) {
      const credential = await getBaseAccess(vc, options, solidVc.SolidAccessGrant);
      if (!credential.has(quad$2(namedNode(solidClientVc.getId(credential)), TYPE, solidVc.SolidAccessGrant)) &&
          !credential.has(quad$2(namedNode(solidClientVc.getId(credential)), TYPE, solidVc.SolidAccessDenial))) {
          throw new Error(`An error occurred when type checking the VC: Not of type [${solidVc.SolidAccessGrant.value}] or [${solidVc.SolidAccessDenial.value}].`);
      }
      return solidClientVc.revokeVerifiableCredential(new URL("status", solidClientVc.getIssuer(credential)).href, solidClientVc.getId(credential), {
          fetch: await getSessionFetch(options),
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Cancel a request for access to data (with explicit or implicit consent) before
   * the person being asked for access has replied.
   * This is equivalent to revoking a access grant.
   *
   * @param vc The access request, either in the form of a VC URL or a full-fledged VC.
   * @param options Optional properties to customise the access request behaviour.
   * @returns A void promise
   * @since 0.0.1
   */
  async function cancelAccessRequest(vc, options = {}) {
      return revokeAccessGrant(vc, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function is not required when using the RDFJS API
   */
  function accessToResourceAccessModeArray(desiredAccess) {
      const modes = [];
      if (desiredAccess.read === true) {
          modes.push(ACL_RESOURCE_ACCESS_MODE_READ);
      }
      if (desiredAccess.append === true) {
          modes.push(ACL_RESOURCE_ACCESS_MODE_APPEND);
      }
      if (desiredAccess.write === true) {
          modes.push(ACL_RESOURCE_ACCESS_MODE_WRITE);
      }
      return modes;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the VC,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseRequest(vc) {
      return vc.credentialSubject.hasConsent !== undefined;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  function getGConsentAttributes(params, type) {
      const modes = accessToResourceAccessModeArray(params.access);
      const consentAttributes = {
          mode: modes,
          hasStatus: params.status,
          forPersonalData: params.resources,
      };
      if (params.purpose !== undefined) {
          consentAttributes.forPurpose = params.purpose;
      }
      if (params.inherit !== undefined) {
          consentAttributes.inherit = params.inherit;
      }
      if (type === "BaseGrantBody") {
          return {
              ...consentAttributes,
              isProvidedTo: params.requestor,
          };
      }
      return {
          ...consentAttributes,
          isConsentForDataSubject: params.resourceOwner,
      };
  }
  function getBaseBody(params, type) {
      const body = {
          "@context": ACCESS_GRANT_CONTEXT_DEFAULT,
          type: [
              type === "BaseGrantBody"
                  ? CREDENTIAL_TYPE_ACCESS_GRANT
                  : CREDENTIAL_TYPE_ACCESS_REQUEST,
          ],
          credentialSubject: {
              inbox: params.requestorInboxUrl,
          },
      };
      if (params.issuanceDate !== undefined) {
          body.issuanceDate = params.issuanceDate.toISOString();
      }
      if (params.expirationDate !== undefined) {
          body.expirationDate =
              params.expirationDate.toISOString();
      }
      if (type === "BaseGrantBody") {
          return {
              ...body,
              credentialSubject: {
                  ...body.credentialSubject,
                  providedConsent: getGConsentAttributes(params, type),
              },
          };
      }
      return {
          ...body,
          credentialSubject: {
              ...body.credentialSubject,
              hasConsent: getGConsentAttributes(params, type),
          },
      };
  }
  function getRequestBody(params) {
      return getBaseBody(params, "BaseRequestBody");
  }
  function getGrantBody(params) {
      return getBaseBody(params, "BaseGrantBody");
  }
  async function issueAccessVc(vcBody, options = {}) {
      const fetcher = await getSessionFetch(options);
      const targetResourceIri = isBaseRequest(vcBody)
          ? vcBody.credentialSubject.hasConsent.forPersonalData[0]
          : vcBody.credentialSubject.providedConsent
              .forPersonalData[0];
      // TODO: find out if concatenating "issue" here is correct
      // It seems like the issuer endpoint should be discovered from the well-known direcly
      // And the access endpoint should be an object with one URI per service
      // (issuer service, verifier service... supposedly status and query and vc???)
      const accessIssuerEndpoint = new URL("issue", await getAccessApiEndpoint(targetResourceIri, options));
      const issuedVc = await solidClientVc.issueVerifiableCredential(accessIssuerEndpoint.href, {
          "@context": instanciateEssAccessGrantContext(accessIssuerEndpoint.hostname),
          ...vcBody.credentialSubject,
      }, {
          // All the required context is provided by instanciateEssAccessGrantContext,
          // and vcBody contains a default context we don't want to include in the
          // result VC.
          "@context": [],
          type: vcBody.type,
          issuanceDate: vcBody.issuanceDate,
          expirationDate: vcBody.expirationDate,
      }, {
          fetch: fetcher,
          returnLegacyJsonld: options.returnLegacyJsonld,
          normalize: options.normalize,
      });
      return issuedVc;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Request,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isRequestCredentialSubject(x) {
      return x.hasConsent !== undefined;
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Request,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseAccessRequestVerifiableCredential(x) {
      return (isBaseAccessVcBody(x) &&
          isRequestCredentialSubject(x.credentialSubject) &&
          isGConsentAttributes(x.credentialSubject.hasConsent));
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad: quad$1, defaultGraph: defaultGraph$1 } = n3.DataFactory;
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Request,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isAccessRequest(x) {
      return (isBaseAccessRequestVerifiableCredential(x) &&
          ACCESS_REQUEST_STATUS.has(x.credentialSubject.hasConsent.hasStatus) &&
          x.credentialSubject.hasConsent.isConsentForDataSubject !== undefined &&
          typeof x.issuanceDate === "string");
  }
  function isRdfjsAccessRequest(dataset) {
      // We shouldn't ned this since getVerifiableCredential will be calling htis
      if (!isRdfjsAccessVerifiableCredential(dataset, [solidVc.SolidAccessRequest])) {
          return false;
      }
      try {
          // This will error if there is no issuance date and return false.
          // This is the behavior we want since Access Requests must have an issuance date
          solidClientVc.getIssuanceDate(dataset);
          const requestClaimSubject = getSingleObject(dataset, solidClientVc.getCredentialSubject(dataset), gc.hasConsent);
          return (dataset.has(quad$1(requestClaimSubject, gc.hasStatus, gc.ConsentStatusRequested)) &&
              dataset.match(requestClaimSubject, gc.isConsentForDataSubject, null, defaultGraph$1()).size === 1 &&
              isRdfjsGConsentAttributes(dataset, requestClaimSubject));
      }
      catch (_a) {
          return false;
      }
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Internal function. This is a stopgap until we have proper JSON-LD parsing.
   * It enforces the shape of the JSON returned by the issuer service, which may
   * vary while still serializing the same data.
   *
   * In particular, this transforms some literals into a one-value array.
   *
   * @hidden
   * @param accessRequest The grant returned by the VC issuer
   * @returns An equivalent JSON-LD document framed according to our typing.
   */
  function normalizeAccessRequest(accessRequest) {
      // Proper type checking is performed after normalization, so casting here is fine.
      const normalized = { ...accessRequest };
      if (!Array.isArray(normalized.credentialSubject.hasConsent.mode)) {
          normalized.credentialSubject.hasConsent.mode = [
              normalized.credentialSubject.hasConsent.mode,
          ];
      }
      if (!Array.isArray(normalized.credentialSubject.hasConsent.forPersonalData)) {
          normalized.credentialSubject.hasConsent.forPersonalData = [
              normalized.credentialSubject.hasConsent.forPersonalData,
          ];
      }
      if (typeof normalized.credentialSubject.hasConsent.inherit === "string") {
          // Literals are also interpreted based on the JSON-LD context, so a "true" value
          // could map to a "true"^^xsd:boolean, which is a boolean.
          normalized.credentialSubject.hasConsent.inherit =
              normalized.credentialSubject.hasConsent.inherit === "true";
      }
      // Cast back to the original type
      return normalized;
  }
  async function issueAccessRequest(params, options = {}) {
      const requestBody = getRequestBody({
          ...params,
          status: gc.ConsentStatusRequested.value,
      });
      if (options.returnLegacyJsonld === false) {
          const accessRequest = await issueAccessVc(requestBody, {
              ...options,
              returnLegacyJsonld: false,
          });
          if (!isRdfjsAccessRequest(accessRequest)) {
              throw new Error(`${JSON.stringify(accessRequest)} is not an Access Request`);
          }
          return accessRequest;
      }
      const accessRequest = await issueAccessVc(requestBody, {
          ...options,
          normalize: normalizeAccessRequest,
      });
      if (!isAccessRequest(accessRequest)) {
          throw new Error(`${JSON.stringify(accessRequest)} is not an Access Request`);
      }
      return accessRequest;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Grant,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isGrantCredentialSubject(x) {
      return x.providedConsent !== undefined;
  }
  /**
   * @deprecated This function checks structural assumptions about the JSON-LD presentation of the Access Grant,
   * which is not recommended. Use the RDFJS API that is now provided instead.
   */
  function isBaseAccessGrantVerifiableCredential(x) {
      return (isBaseAccessVcBody(x) &&
          isGrantCredentialSubject(x.credentialSubject) &&
          isGConsentAttributes(x.credentialSubject.providedConsent));
  }
  function isRdfjsBaseAccessGrantVerifiableCredential(data) {
      return isRdfjsAccessVerifiableCredential(data, [
          solidVc.SolidAccessDenial,
          solidVc.SolidAccessGrant,
      ]);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const { quad, literal, defaultGraph } = n3.DataFactory;
  const inheritQuad = (subject, inherit) => quad(subject, INHERIT, literal(inherit ? "true" : "false", XSD_BOOLEAN), defaultGraph());
  function getInherit(vc) {
      if (vc.has(inheritQuad(getConsent(vc), true))) {
          return true;
      }
      if (vc.has(inheritQuad(getConsent(vc), false))) {
          return false;
      }
      return undefined;
  }
  function initializeGrantParameters(requestVc, requestOverride) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const resultGrant = requestVc === undefined
          ? requestOverride
          : {
              requestor: (_a = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.requestor) !== null && _a !== void 0 ? _a : solidClientVc.getCredentialSubject(requestVc).value,
              access: (_b = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.access) !== null && _b !== void 0 ? _b : getAccessModes(requestVc),
              resources: (_c = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.resources) !== null && _c !== void 0 ? _c : getResources(requestVc),
              requestorInboxUrl: (_d = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.requestorInboxUrl) !== null && _d !== void 0 ? _d : getInbox(requestVc),
              issuanceDate: (_e = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.issuanceDate) !== null && _e !== void 0 ? _e : solidClientVc.getIssuanceDate(requestVc),
              purpose: (_f = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.purpose) !== null && _f !== void 0 ? _f : getPurposes(requestVc),
              expirationDate: (_g = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.expirationDate) !== null && _g !== void 0 ? _g : solidClientVc.getExpirationDate(requestVc),
              inherit: (_h = requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.inherit) !== null && _h !== void 0 ? _h : getInherit(requestVc),
          };
      if ((requestOverride === null || requestOverride === void 0 ? void 0 : requestOverride.expirationDate) === null) {
          resultGrant.expirationDate = undefined;
      }
      return resultGrant;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // eslint-disable-next-line camelcase
  /**
   * Internal function. This is a stopgap until we have proper JSON-LD parsing.
   * It enforces the shape of the JSON returned by the issuer service, which may
   * vary while still serializing the same data.
   *
   * In particular, this transforms some literals into a one-value array.
   *
   * @hidden
   * @param accessGrant The grant returned by the VC issuer
   * @returns An equivalent JSON-LD document framed according to our typing.
   */
  function normalizeAccessGrant(accessGrant) {
      // Proper type checking is performed after normalization, so casting here is fine.
      const normalized = { ...accessGrant };
      if (normalized.credentialSubject.providedConsent === undefined) {
          throw new Error(`[${normalized.id}] is not an Access Grant: missing field "credentialSubject.providedConsent".`);
      }
      if (!Array.isArray(normalized.credentialSubject.providedConsent.mode)) {
          normalized.credentialSubject.providedConsent.mode = [
              normalized.credentialSubject.providedConsent.mode,
          ];
      }
      if (!Array.isArray(normalized.credentialSubject.providedConsent.forPersonalData)) {
          normalized.credentialSubject.providedConsent.forPersonalData = [
              normalized.credentialSubject.providedConsent.forPersonalData,
          ];
      }
      if (typeof normalized.credentialSubject.providedConsent.inherit === "string") {
          // Literals are also interpreted based on the JSON-LD context, so a "true" value
          // could map to a "true"^^xsd:boolean, which is a boolean.
          normalized.credentialSubject.providedConsent.inherit =
              normalized.credentialSubject.providedConsent.inherit === "true";
      }
      // Cast back to the original type
      return normalized;
  }
  function getAccessModesFromAccessGrant(request) {
      const accessMode = {};
      const requestModes = request.credentialSubject.providedConsent.mode;
      accessMode.append = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_APPEND);
      accessMode.read = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_READ);
      accessMode.write = requestModes.includes(ACL_RESOURCE_ACCESS_MODE_WRITE);
      return accessMode;
  }
  async function addVcMatcher(targetResources, accessMode, options) {
      return Promise.all(targetResources.map(async (targetResource) => {
          var _a;
          // eslint-disable-next-line camelcase
          const resourceInfo = await solidClient.acp_ess_2.getResourceInfoWithAcr(targetResource, options);
          // eslint-disable-next-line camelcase
          if (!solidClient.acp_ess_2.hasAccessibleAcr(resourceInfo)) {
              throw new Error("The current user does not have access to the resource's Access Control Resource. Either they have insufficiant credentials, or the resource is not controlled using ACP. In either case, an Access Grant cannot be issued.");
          }
          // eslint-disable-next-line camelcase
          const updatedResource = solidClient.acp_ess_2.setVcAccess(resourceInfo, accessMode, {
              inherit: (_a = options === null || options === void 0 ? void 0 : options.inherit) !== null && _a !== void 0 ? _a : true,
          });
          // eslint-disable-next-line camelcase
          return solidClient.acp_ess_2.saveAcrFor(updatedResource, options);
      }));
  }
  async function approveAccessRequest(requestVc, requestOverride, options = {}) {
      var _a, _b, _c;
      const internalOptions = {
          ...options,
          fetch: (_a = options.fetch) !== null && _a !== void 0 ? _a : (await getSessionFetch(options)),
          updateAcr: (_b = options.updateAcr) !== null && _b !== void 0 ? _b : true,
      };
      const internalGrantOptions = initializeGrantParameters(typeof requestVc !== "undefined"
          ? await getBaseAccess(requestVc, options, solidVc.SolidAccessRequest, gc.ConsentStatusRequested)
          : undefined, requestOverride);
      const grantBody = getGrantBody({
          access: internalGrantOptions.access,
          requestor: internalGrantOptions.requestor,
          resources: internalGrantOptions.resources,
          requestorInboxUrl: internalGrantOptions.requestorInboxUrl,
          purpose: internalGrantOptions.purpose,
          issuanceDate: internalGrantOptions.issuanceDate,
          expirationDate: (_c = internalGrantOptions.expirationDate) !== null && _c !== void 0 ? _c : undefined,
          status: gc.ConsentStatusExplicitlyGiven.value,
          inherit: internalGrantOptions.inherit,
      });
      const grantedAccess = getAccessModesFromAccessGrant(grantBody);
      if (internalOptions.updateAcr === true) {
          await addVcMatcher(grantBody.credentialSubject.providedConsent.forPersonalData, grantedAccess, internalOptions);
      }
      const accessGrant = await issueAccessVc(grantBody, {
          ...internalOptions,
          returnLegacyJsonld: options.returnLegacyJsonld,
          normalize: normalizeAccessGrant,
      });
      if (options.returnLegacyJsonld !== false
          ? !isBaseAccessGrantVerifiableCredential(accessGrant) ||
              !isAccessGrant(accessGrant)
          : !isRdfjsBaseAccessGrantVerifiableCredential(accessGrant)) {
          throw new Error(`Unexpected response when approving Access Request, the result is not an Access Grant: ${JSON.stringify(accessGrant)}`);
      }
      return accessGrant;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function denyAccessRequest(vc, options) {
      const baseVc = await getBaseAccess(vc, options !== null && options !== void 0 ? options : {}, solidVc.SolidAccessRequest);
      const internalOptions = initializeGrantParameters(baseVc);
      const denialBody = getGrantBody({
          access: internalOptions.access,
          requestor: internalOptions.requestor,
          resources: internalOptions.resources,
          requestorInboxUrl: internalOptions.requestorInboxUrl,
          status: gc.ConsentStatusExplicitlyGiven.value,
          purpose: internalOptions.purpose,
          // denyAccessRequest doesn't take an override, so the expiration date
          // cannot be null.
          expirationDate: internalOptions.expirationDate,
      });
      denialBody.type = [CREDENTIAL_TYPE_ACCESS_DENIAL];
      denialBody.credentialSubject.providedConsent.hasStatus =
          gc.ConsentStatusDenied.value;
      return issueAccessVc(denialBody, {
          ...options,
          normalize: normalizeAccessGrant,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Retrieve the Access Grant associated to the given URL.
   *
   * @param accessGrantVcUrl The URL of an access grant, with or without consent.
   * @param options Optional properties to customise the request behaviour.
   * @returns The Verifiable Credential associated to the given IRI, if it is an access grant. Throws otherwise.
   * @since 0.4.0
   */
  async function getAccessGrant(accessGrantVcUrl, options) {
      const vcUrl = typeof accessGrantVcUrl === "string"
          ? accessGrantVcUrl
          : accessGrantVcUrl.href;
      if ((options === null || options === void 0 ? void 0 : options.returnLegacyJsonld) === false) {
          const data = await solidClientVc.getVerifiableCredential(vcUrl, {
              fetch: options === null || options === void 0 ? void 0 : options.fetch,
              returnLegacyJsonld: false,
          });
          if (!isRdfjsBaseAccessGrantVerifiableCredential(data) ||
              !isGConsentAccessGrant(data)) {
              throw new Error(`Unexpected response when resolving [${vcUrl}], the result is not an Access Grant: ${JSON.stringify(data, null, 2)}`);
          }
          return data;
      }
      const data = await solidClientVc.getVerifiableCredential(vcUrl, {
          fetch: options === null || options === void 0 ? void 0 : options.fetch,
          normalize: normalizeAccessGrant,
      });
      if (!isBaseAccessGrantVerifiableCredential(data) || !isAccessGrant(data)) {
          throw new Error(`Unexpected response when resolving [${vcUrl}], the result is not an Access Grant: ${JSON.stringify(data)}`);
      }
      return data;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  // Iteratively build the list of ancestor containers from the breakdown of the
  // resource path: for resource https://pod.example/foo/bar/baz, we'll want the result
  // to be ["https://pod.example/", "https://pod.example/foo/", "https://pod.example/foo/bar/", https://pod.example/foo/bar/baz].
  const getAncestorUrls = (resourceUrl) => {
      // Splitting on / will result in the first element being empty (since the path
      // starts with /) and in the last element being the target resource name.
      const ancestorNames = resourceUrl.pathname
          .split("/")
          .slice(1, resourceUrl.pathname.endsWith("/") ? -2 : -1);
      return ancestorNames.reduce((ancestors, curName) => {
          // Add each intermediary container to ancestorPaths
          const currentPath = `${ancestors[0]}${curName}/`;
          return [new URL(currentPath, resourceUrl.origin), ...ancestors];
      }, 
      // The storage origin may be the storage root (it happens not to be the case in ESS).
      // The target resource should also be included.
      [new URL("/", resourceUrl.origin), resourceUrl]);
  };
  async function getAccessGrantAll(params, options = {}) {
      var _a, _b;
      if (!params.resource && !options.accessEndpoint) {
          throw new Error("resource and accessEndpoint cannot both be undefined");
      }
      const sessionFetch = await getSessionFetch(options);
      // TODO: Fix access API endpoint retrieval (should include all the different API endpoints)
      const queryEndpoint = options.accessEndpoint
          ? new URL("derive", options.accessEndpoint)
          : new URL("derive", await getAccessApiEndpoint(params.resource, options));
      const ancestorUrls = params.resource
          ? getAncestorUrls(typeof params.resource === "string"
              ? new URL(params.resource)
              : params.resource)
          : [undefined];
      const specifiedModes = accessToResourceAccessModeArray((_a = params.access) !== null && _a !== void 0 ? _a : {});
      const type = [CREDENTIAL_TYPE_BASE];
      const statusShorthand = (_b = params.status) !== null && _b !== void 0 ? _b : "granted";
      if (statusShorthand === "granted") {
          type.push(CREDENTIAL_TYPE_ACCESS_GRANT);
      }
      else if (statusShorthand === "denied") {
          type.push(CREDENTIAL_TYPE_ACCESS_DENIAL);
      }
      const vcShapes = ancestorUrls.map((url) => ({
          "@context": [CONTEXT_VC_W3C, CONTEXT_ESS_DEFAULT],
          type,
          credentialSubject: {
              providedConsent: {
                  hasStatus: {
                      granted: gc.ConsentStatusExplicitlyGiven.value,
                      denied: gc.ConsentStatusDenied.value,
                      all: undefined,
                  }[statusShorthand],
                  forPersonalData: url ? [url.href] : undefined,
                  forPurpose: params.purpose,
                  isProvidedTo: params.requestor,
                  mode: specifiedModes.length > 0 ? specifiedModes : undefined,
              },
          },
      }));
      let result;
      if (options.returnLegacyJsonld === false) {
          // TODO: Fix up the type of accepted arguments (this function should allow deep partial)
          result = (await Promise.all(vcShapes.map((vcShape) => solidClientVc.getVerifiableCredentialAllFromShape(queryEndpoint.href, vcShape, {
              fetch: sessionFetch,
              includeExpiredVc: options.includeExpired,
              returnLegacyJsonld: false,
          }))))
              // getVerifiableCredentialAllFromShape returns a list, so the previous map
              // should be flattened to have all the candidate grants in a non-nested list.
              .flat()
              .filter((vc) => isRdfjsBaseAccessGrantVerifiableCredential(vc));
      }
      else {
          result = (await Promise.all(vcShapes.map((vcShape) => solidClientVc.getVerifiableCredentialAllFromShape(queryEndpoint.href, vcShape, {
              fetch: sessionFetch,
              includeExpiredVc: options.includeExpired,
              normalize: normalizeAccessGrant,
          }))))
              // getVerifiableCredentialAllFromShape returns a list, so the previous map
              // should be flattened to have all the candidate grants in a non-nested list.
              .flat()
              .filter((vc) => isBaseAccessGrantVerifiableCredential(vc) && isAccessGrant(vc));
      }
      // Explicitly non-recursive grants are filtered out, except if they apply
      // directly to the target resource (in the case a resource is used as a
      // filtering criteria for getAccessGrantAll).
      return result.filter((vc) => getInherit$1(vc) !== false ||
          params.resource === undefined ||
          getResources(vc).includes(params.resource.toString()));
  }

  /**
   * Fetch the Access Request from the given URL.
   *
   * @param url The URL of the Access Request.
   * @param options Optional properties to customise the behaviour:
   * - fetch: an authenticated fetch function. If not provided, the default session
   * from @inrupt/solid-client-authn-browser will be used if available.
   * @returns An Access Request.
   * @since 2.4.0
   * @deprecated Use RDFJS API instead of relying on the JSON structure by setting `returnLegacyJsonld` to false
   */
  async function getAccessRequest(url, options = {}) {
      var _a, _b;
      if ((options === null || options === void 0 ? void 0 : options.returnLegacyJsonld) === false) {
          const accessRequest = await solidClientVc.getVerifiableCredential(url.toString(), {
              fetch: (_a = options.fetch) !== null && _a !== void 0 ? _a : (await getSessionFetch(options)),
              returnLegacyJsonld: false,
          });
          if (!isRdfjsAccessRequest(accessRequest)) {
              throw new Error(`${JSON.stringify(accessRequest)} is not an Access Request`);
          }
          return accessRequest;
      }
      const accessRequest = await solidClientVc.getVerifiableCredential(url.toString(), {
          fetch: (_b = options.fetch) !== null && _b !== void 0 ? _b : (await getSessionFetch(options)),
          normalize: normalizeAccessRequest,
      });
      if (!isAccessRequest(accessRequest)) {
          throw new Error(`${JSON.stringify(accessRequest, null, 2)} is not an Access Request`);
      }
      return accessRequest;
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  function getSearchParam(url, param) {
      const value = url.searchParams.get(param);
      if (value === null) {
          throw new Error(`The provided redirect URL [${url.toString()}] is missing the expected [${param}] query parameter`);
      }
      return value;
  }
  async function getAccessRequestFromRedirectUrl(redirectUrl, options) {
      const redirectUrlObj = typeof redirectUrl === "string" ? new URL(redirectUrl) : redirectUrl;
      // Get the URL where the requestor expects the user to be redirected with
      // the grant.
      const requestorRedirectUrl = getSearchParam(redirectUrlObj, REDIRECT_URL_PARAM_NAME);
      // Get the Access Request IRI.
      const accessRequestIri = getSearchParam(redirectUrlObj, REQUEST_VC_URL_PARAM_NAME);
      return {
          accessRequest: await getAccessRequest(accessRequestIri, options),
          requestorRedirectUrl,
      };
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const GRANT_VC_URL_PARAM_NAME = "accessGrantUrl";
  /**
   * Redirect the user to the client which requested Access to a Resource. The Access
   * Grant is sent as part of the redirect.
   *
   * @param accessGrantVcId The ID of the Access Grant VC, which should be a URL
   * @param redirectUrl The URL where the client requesting access expects the
   * user to be redirected
   * @param options If you are in a NodeJS environment, you must specify a
   * callback to handle the redirection.
   * @returns A never resolving promise: the user is expected to be redirected away
   * from the page by this call, so no code should be expected to run in that context
   * after the redirect.
   * @since 0.5.0
   */
  async function redirectToRequestor(accessGrantVcId, redirectUrl, options = {}) {
      return redirectWithParameters(redirectUrl.toString(), {
          [`${GRANT_VC_URL_PARAM_NAME}`]: encodeURI(accessGrantVcId.toString()),
      }, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  async function getAccessGrantFromRedirectUrl(redirectUrl, options = {}) {
      const redirectUrlObj = typeof redirectUrl === "string" ? new URL(redirectUrl) : redirectUrl;
      const accessGrantIri = redirectUrlObj.searchParams.get(GRANT_VC_URL_PARAM_NAME);
      if (accessGrantIri === null) {
          throw new Error(`The provided redirect URL [${redirectUrl}] is missing the expected [${GRANT_VC_URL_PARAM_NAME}] query parameter`);
      }
      return getAccessGrant(accessGrantIri, options);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GRANT_VC_URL_PARAM_NAME: GRANT_VC_URL_PARAM_NAME,
    approveAccessRequest: approveAccessRequest,
    cancelAccessRequest: cancelAccessRequest,
    denyAccessRequest: denyAccessRequest,
    getAccessApiEndpoint: getAccessApiEndpoint,
    getAccessGrant: getAccessGrant,
    getAccessGrantAll: getAccessGrantAll,
    getAccessGrantFromRedirectUrl: getAccessGrantFromRedirectUrl,
    getAccessManagementUi: getAccessManagementUi,
    getAccessRequest: getAccessRequest,
    getAccessRequestFromRedirectUrl: getAccessRequestFromRedirectUrl,
    issueAccessRequest: issueAccessRequest,
    redirectToAccessManagementUi: redirectToAccessManagementUi,
    redirectToRequestor: redirectToRequestor,
    revokeAccessGrant: revokeAccessGrant
  });

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  const WWW_AUTH_HEADER = "www-authenticate";
  const VC_CLAIM_TOKEN_TYPE = "https://www.w3.org/TR/vc-data-model/#json-ld";
  const UMA_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:uma-ticket";
  const UMA_CONFIG_PATH = "/.well-known/uma2-configuration";
  const NO_WWW_AUTH_HEADER_ERROR = "No www-authentication header found in response headers; UMA cannot proceed. Refer to your network requests for details.";
  const NO_WWW_AUTH_HEADER_UMA_TICKET_ERROR = 'www-authentication header in response headers did not include "ticket"; UMA cannot proceed. Refer to your network requests for details.';
  const NO_WWW_AUTH_HEADER_UMA_IRI_ERROR = 'www-authentication header in response headers did not include "as_uri"; UMA cannot proceed. Refer to your network requests for details.';
  const NO_ACCESS_TOKEN_RETURNED = "No access token was returned during the UMA exchange flow. Refer to your network requests for details.";
  const UMA_TICKET_REGEX = /ticket="([^"]+)"/;
  const UMA_IRI_REGEX = /as_uri="([^"]+)"/;
  /**
   * @hidden This is just an internal utility function to parse the ticket value out of the www-authenticate header.
   */
  function parseUMAAuthTicket(header) {
      const matches = UMA_TICKET_REGEX.exec(header);
      return matches ? matches[1] : null;
  }
  /**
   * @hidden This is just an internal utility function to parse the as_uri value out of the www-authenticate header.
   */
  function parseUMAAuthIri(header) {
      const matches = UMA_IRI_REGEX.exec(header);
      return matches ? matches[1] : null;
  }
  /**
   * @hidden This is just an internal utility function to get the UMA configuration from .well-known.
   */
  async function getUmaConfiguration(authIri) {
      const configurationUrl = new URL(UMA_CONFIG_PATH, authIri).href;
      const response = await fetch(configurationUrl);
      return response.json().catch((e) => {
          throw new Error(`Parsing the UMA configuration found at ${configurationUrl} failed with the following error: ${e.toString()}`);
      });
  }
  /**
   * @hidden This is just an internal utility function to exchange a VC and ticket for an auth token.
   */
  async function exchangeTicketForAccessToken(tokenEndpoint, accessGrant, authTicket, authFetch) {
      const credentialPresentation = {
          "@context": [CONTEXT_VC_W3C, CONTEXT_ESS_DEFAULT],
          type: [PRESENTATION_TYPE_BASE],
          verifiableCredential: [accessGrant],
      };
      const response = await authFetch(tokenEndpoint, {
          method: "POST",
          headers: {
              "Content-Type": "application/x-www-form-urlencoded",
          },
          body: new URLSearchParams({
              claim_token: base64url.encode(JSON.stringify(credentialPresentation)),
              claim_token_format: VC_CLAIM_TOKEN_TYPE,
              grant_type: UMA_GRANT_TYPE,
              ticket: authTicket,
          }).toString(),
      });
      try {
          const data = await response.json();
          return data.access_token || null;
      }
      catch (_e) {
          // An error being thown here means that the response body doesn't parse as JSON.
          return null;
      }
  }
  /**
   * @hidden This is just an internal utility function to bind a fetch function to the UMA auth token.
   */
  function boundFetch(accessToken) {
      // Explicitly use a named function such that it appears in stacktraces
      return function authenticatedFetch(url, init) {
          return fetch(url, {
              ...init,
              headers: {
                  ...((init === null || init === void 0 ? void 0 : init.headers) || {}),
                  authorization: `Bearer ${accessToken}`,
              },
          });
      };
  }
  /**
   * Builds a WHATWG Fetch compatible function issuing authenticated requests
   * based on an Access Grant VC. The obtained fetch function authentication will
   * only be valid for the resources included in the Access Grant.
   *
   * Note that providing an authenticated `fetch` as an option is mandatory for
   * the resulting fetch to be valid. The input fetch should be authenticated to
   * the requestor's Solid-OIDC provider.
   *
   * @param resourceIri One of the resources from the Access Grant.
   * @param accessGrant The Verifiable Credential proving that the requestor has
   * been granted access to the target resource.
   * @param options Additional fetch options, allowing you to override the
   * `fetch()` implementation
   * @returns A Promise resolving to a WHATWG Fetch compatible function matching
   * the standard signature. The obtained fetch function will override any
   * provided `Authentication` header with authentication information obtained
   * thanks to the provided VC.
   * @since 0.4.0
   */
  async function fetchWithVc(
  // Why UrlString instead of UrlString | Url? Because Urls aren't compatible
  // with the fetch return type.
  resourceIri, accessGrant, options) {
      var _a;
      // Use an authenticated session to fetch the resource so that we can parse
      // its headers to find the UMA endpoint information and ticket
      const response = await fetch(resourceIri);
      const { headers } = response;
      const wwwAuthentication = headers.get(WWW_AUTH_HEADER);
      if (!wwwAuthentication) {
          throw new Error(NO_WWW_AUTH_HEADER_ERROR);
      }
      const authTicket = parseUMAAuthTicket(wwwAuthentication);
      const authIri = parseUMAAuthIri(wwwAuthentication);
      if (!authTicket) {
          throw new Error(NO_WWW_AUTH_HEADER_UMA_TICKET_ERROR);
      }
      if (!authIri) {
          throw new Error(NO_WWW_AUTH_HEADER_UMA_IRI_ERROR);
      }
      const umaConfiguration = await getUmaConfiguration(authIri);
      const tokenEndpoint = umaConfiguration.token_endpoint;
      const accessToken = await exchangeTicketForAccessToken(tokenEndpoint, accessGrant, authTicket, (_a = options === null || options === void 0 ? void 0 : options.fetch) !== null && _a !== void 0 ? _a : fetch);
      if (!accessToken) {
          throw new Error(NO_ACCESS_TOKEN_RETURNED);
      }
      return boundFetch(accessToken);
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Retrieve a File from a Solid Pod using an Access Grant to prove the caller is
   * authorized to access the target resource.
   *
   * @see [@inrupt/solid-client's
   * getFile](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_file.html#getfile)
   *
   * @param resourceUrl The URL of the target resource.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a File if successful, and that rejects
   * otherwise.
   * @since 0.4.0
   */
  async function getFile(resourceUrl, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(resourceUrl, accessGrant, fetchOptions);
      return await solidClient.getFile(resourceUrl, {
          fetch: authenticatedFetch,
      });
  }
  /**
   * Overwrites the file using an Access Grant to prove the caller is authorized
   * to write to the given resource URL.
   *
   * ```{note} This function does not support saving a file if the file does not
   * yet exist, unlike its `@inrupt/solid-client` counterpart. To save a new file
   * in a container, you should use [saveFileInContainer](#savefileincontainer)
   * instead.
   * ```
   *
   * @see [@inrupt/solid-client's
   * overwriteFile](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_file.html#overwritefile)
   *
   * @param resourceUrl The URL where the file is located.
   * @param file The file to be written.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour, or
   * override the Content-Type of the file.
   * @returns A promise that resolves to a File if successful, and that rejects
   * otherwise.
   * @since 1.1.0
   */
  async function overwriteFile(resourceUrl, file, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(resourceUrl, accessGrant, fetchOptions);
      const overwriteFileOptions = {};
      if (options && options.contentType) {
          overwriteFileOptions.contentType = options.contentType;
      }
      return await solidClient.overwriteFile(resourceUrl, file, {
          ...overwriteFileOptions,
          fetch: authenticatedFetch,
      });
  }
  /**
   * Saves a file in the given container URL using an Access Grant to prove the caller is
   * authorized to save a file in the given container.
   *
   * @see [@inrupt/solid-client's
   * saveFileInContainer](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_file.html#savefileincontainer)
   *
   * @param containerUrl The container URL where the file is to be saved.
   * @param file The file to be written.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour, or override the Content-Type of the file.
   * @returns A promise that resolves to a File if successful, and that rejects
   * otherwise.
   * @since 1.1.0
   */
  async function saveFileInContainer(containerUrl, file, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(containerUrl, accessGrant, fetchOptions);
      const fileOptions = {};
      if (options && options.contentType) {
          fileOptions.contentType = options.contentType;
      }
      if (options && options.slug) {
          fileOptions.slug = options.slug;
      }
      return await solidClient.saveFileInContainer(containerUrl, file, {
          ...fileOptions,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Create an empty Container inside the Container at the given URL.
   *
   * Throws an error if creating the Container failed, e.g. because the current user does not have
   * permissions to. In particular, the Access Grant being used should at least append access to the target Container.
   *
   * The Container in which to create the new Container should itself already exist.
   *
   * This function is primarily useful if the current user does not have access to change existing files in
   * a Container, but is allowed to add new files; in other words, they have Append, but not Write
   * access to a Container. This is useful in situations where someone wants to allow others to,
   * for example, send notifications to their Pod, but not to view or delete existing notifications.
   * You can pass a suggestion for the new Resource's name, but the server may decide to give it
   * another name — for example, if a Resource with that name already exists inside the given
   * Container.
   * If the user does have access to write directly to a given location, createContainerAt
   * will do the job just fine, and does not require the parent Container to exist in advance.
   *
   * @param containerUrl URL of the Container in which the empty Container is to
   * be created.
   * @param accessGrant The Access Grant that would allow the Agent/Application to
   * perform this operation.
   * @param options Optional parameter:
   * - `options.fetch`: An alternative `fetch` function to make the HTTP request,
   *   compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
   * @returns A promise that resolves to a SolidDataset with ResourceInfo if
   * successful, and that rejects otherwise.
   * @since 2.1.0
   */
  async function createContainerInContainer(containerUrl, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(containerUrl, accessGrant, fetchOptions);
      return await solidClient.createContainerInContainer(containerUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Delete a File from a Solid Pod using an Access Grant to prove the caller
   * is authorized to overwrite the target file.
   *
   * @see [@inrupt/solid-client's
   * deleteSolidDataset](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#deletefile)
   *
   * @param fileUrl The URL of the target file.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since unreleased
   */
  async function deleteFile(fileUrl, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(fileUrl, accessGrant, fetchOptions);
      return await solidClient.deleteFile(fileUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Delete a Dataset from a Solid Pod using an Access Grant to prove the caller
   * is authorized to overwrite the target dataset.
   *
   * @see [@inrupt/solid-client's
   * deleteSolidDataset](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#deletesoliddataset)
   *
   * @param datasetUrl The URL of the target dataset.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since unreleased
   */
  async function deleteSolidDataset(datasetUrl, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(datasetUrl, accessGrant, fetchOptions);
      return await solidClient.deleteSolidDataset(datasetUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Retrieve a Dataset from a Solid Pod using an Access Grant to prove the caller
   * is authorized to access the target dataset.
   *
   * @see [@inrupt/solid-client's
   * getSolidDataset](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#getsoliddataset)
   *
   * @param datasetUrl The URL of the target dataset.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since 0.4.0
   */
  async function getSolidDataset(datasetUrl, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(datasetUrl, accessGrant, fetchOptions);
      return await solidClient.getSolidDataset(datasetUrl, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Saves a Dataset in a Solid Pod using an Access Grant to prove the caller is
   * authorized to write or append to the dataset at the given dataset URL.
   *
   * ```{note} This function does not support saving a dataset if the
   * dataset does not yet exist, unlike its `@inrupt/solid-client`
   * counterpart.
   * ```
   *
   * @see [@inrupt/solid-client's
   * saveSolidDatasetAt](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#savesoliddatasetat)
   *
   * @param datasetUrl The URL of the dataset to save.
   * @param accessGrant The Access Grant VC proving the caller is authorized.
   * @param options Optional properties to customise the request behaviour.
   * @returns A promise that resolves to a SolidDataset if successful, and that
   * rejects otherwise.
   * @since 0.4.0
   */
  async function saveSolidDatasetAt(datasetUrl, solidDataset, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(datasetUrl, accessGrant, fetchOptions);
      return await solidClient.saveSolidDatasetAt(datasetUrl, solidDataset, {
          ...options,
          fetch: authenticatedFetch,
      });
  }

  //
  // Copyright Inrupt Inc.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to use,
  // copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
  // Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  // INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  // HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  //
  /**
   * Given a SolidDataset, store it in a Solid Pod as a new Resource inside a Container.
   *
   * The Container at the given URL should already exist; if it does not, you can initialise it first
   * using createContainerAt, or directly save the SolidDataset at the desired location using
   * {@link resource.saveSolidDatasetAt}.
   *
   * This function is primarily useful if the current user has not been granted
   * access to change existing files in a Container, but is allowed to add new
   * files; in other words, they have been granted Append, but not Write access to
   * a Container. This is useful in situations where someone wants to allow others
   * to, for example, send notifications to their Pod, but not to view or delete
   * existing notifications. You can pass a suggestion for the new Resource's
   * name, but the server may decide to give it another name — for example, if a
   * Resource with that name already exists inside the given Container. If the
   * user does have access to write directly to a given location,
   * {@link resource.saveSolidDatasetAt} will do the job just fine, and does not require the
   * parent Container to exist in advance.
   *
   * @see [@inrupt/solid-client's
   * saveSolidDatasetInContainer](https://docs.inrupt.com/developer-tools/api/javascript/solid-client/modules/resource_solidDataset.html#savesoliddatasetincontainer)
   *
   *
   * @param containerUrl URL of the Container in which to create a new Resource.
   * @param solidDataset The SolidDataset to save to a new Resource in the given Container.
   * @param accessGrant The Access Grant that would allow the Agent/Application to perform this operation.
   * @param options Optional parameter `options.fetch`: An alternative `fetch` function to make the HTTP request, compatible with the browser-native [fetch API](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters).
   * @returns A Promise resolving to a SolidDataset containing the saved data. The Promise rejects if the save failed.
   * @since 2.1.0
   */
  async function saveSolidDatasetInContainer(containerUrl, solidDataset, accessGrant, options) {
      const fetchOptions = {};
      if (options && options.fetch) {
          fetchOptions.fetch = options.fetch;
      }
      const authenticatedFetch = await fetchWithVc(containerUrl, accessGrant, fetchOptions);
      const containerOptions = {};
      if (options && options.slugSuggestion) {
          containerOptions.slugSuggestion = options.slugSuggestion;
      }
      return await solidClient.saveSolidDatasetInContainer(containerUrl, solidDataset, {
          ...containerOptions,
          fetch: authenticatedFetch,
      });
  }

  Object.defineProperty(exports, "getCredentialSubject", {
    enumerable: true,
    get: function () { return solidClientVc.getCredentialSubject; }
  });
  Object.defineProperty(exports, "getExpirationDate", {
    enumerable: true,
    get: function () { return solidClientVc.getExpirationDate; }
  });
  Object.defineProperty(exports, "getId", {
    enumerable: true,
    get: function () { return solidClientVc.getId; }
  });
  Object.defineProperty(exports, "getIssuanceDate", {
    enumerable: true,
    get: function () { return solidClientVc.getIssuanceDate; }
  });
  Object.defineProperty(exports, "getIssuer", {
    enumerable: true,
    get: function () { return solidClientVc.getIssuer; }
  });
  exports.AccessGrantWrapper = AccessGrantWrapper;
  exports.CredentialIsAccessGrantAny = CredentialIsAccessGrantAny;
  exports.GRANT_VC_URL_PARAM_NAME = GRANT_VC_URL_PARAM_NAME;
  exports.approveAccessRequest = approveAccessRequest;
  exports.cancelAccessRequest = cancelAccessRequest;
  exports.common = index$1;
  exports.createContainerInContainer = createContainerInContainer;
  exports.deleteFile = deleteFile;
  exports.deleteSolidDataset = deleteSolidDataset;
  exports.denyAccessRequest = denyAccessRequest;
  exports.fetchWithVc = fetchWithVc;
  exports.gConsent = index;
  exports.getAccessApiEndpoint = getAccessApiEndpoint;
  exports.getAccessGrant = getAccessGrant;
  exports.getAccessGrantAll = getAccessGrantAll;
  exports.getAccessGrantFromRedirectUrl = getAccessGrantFromRedirectUrl;
  exports.getAccessManagementUi = getAccessManagementUi;
  exports.getAccessModes = getAccessModes;
  exports.getAccessRequest = getAccessRequest;
  exports.getAccessRequestFromRedirectUrl = getAccessRequestFromRedirectUrl;
  exports.getConsent = getConsent;
  exports.getFile = getFile;
  exports.getInbox = getInbox;
  exports.getInherit = getInherit$1;
  exports.getPurposes = getPurposes;
  exports.getRequestor = getRequestor;
  exports.getResourceOwner = getResourceOwner;
  exports.getResources = getResources;
  exports.getSolidDataset = getSolidDataset;
  exports.getTypes = getTypes;
  exports.isValidAccessGrant = isValidAccessGrant;
  exports.issueAccessRequest = issueAccessRequest;
  exports.overwriteFile = overwriteFile;
  exports.redirectToAccessManagementUi = redirectToAccessManagementUi;
  exports.redirectToRequestor = redirectToRequestor;
  exports.revokeAccessGrant = revokeAccessGrant;
  exports.saveFileInContainer = saveFileInContainer;
  exports.saveSolidDatasetAt = saveSolidDatasetAt;
  exports.saveSolidDatasetInContainer = saveSolidDatasetInContainer;

}));
